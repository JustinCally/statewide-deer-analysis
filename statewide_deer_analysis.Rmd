---
title: "Abundance of Deer in Victoria"
description: |
  Determining abundance of deer species in Victoria using camera trap data
author:
  - name: Justin G Cally
    url: https://justincally.github.io/blog/
    affiliation: Arthur Rylah Institute
    affiliation_url: https://www.ari.vic.gov.au/
date: 2023-07-06
output:
  html_document:
    self_contained: true
    toc: true # table of content true
    toc_float: true # make 
    depth: 3  # upto three depths of headings (specified by #, ## and ###)
    number_sections: false  ## if you want number sections at each table header
    code_folding: true # awesome buttons to show/hide the code
    theme: yeti
slug: statewidedeer
---

# Setup  

```{r setup, include=TRUE}
library(cmdstanr)
library(dplyr)
library(sf)
library(bayesplot)
library(loo)
library(gt)
check_cmdstan_toolchain(fix = TRUE, quiet = TRUE)
options(mc.cores=6)

#### Database connection ####
con <- weda::weda_connect(password = keyring::key_get(service = "ari-dev-weda-psql-01",
                                                username = "psql_user"), username = "psql_user")
```


# Custom Functions  

Additional functions used in the data preparation, modelling and alaysis are available in the `/functions` directory.  

```{r sourcefunctions, echo = FALSE, results = 'hide'}
# Source internal functions
sapply(list.files("functions", full.names = T), source, verbose = F)
```

# Prepare Data  

## Scope of models 

```{r data_params}
# Species to run model for.
deer_species_all <- c("All deer", "Cervus unicolor", "Dama dama", "Cervus elaphus", "Axis porcinus")
# Projects to select.
project_short_name <- c("hog_deer_2023", "StatewideDeer")
# Buffer for data extraction.
spatial_buffer <- 1000
# Covariate Rasters
raster_files <- "/Volumes/DeerVic\ Photos/Processed_Rasters"
prediction_raster <- "data/prediction_raster/vic_model_data_resampled.tif"
n_max_no_det <- 10
n_max_det <- 50
```

## Formulas for detection and abundance. 

```{r formulas}
#### Model formulas ####
transect_formula <- ~Survey
ab_formula <- ~ scale(BIO12)  + scale(BIO04)  + scale(BIO01) + scale(TreeDensity) + scale(sqrt(PastureDistance)) + scale(TWIND) + scale(BIO15) + scale(SLOPE) + scale(MRVBF) + scale(sqrt(ForestEdge))
# Use an intercept only detection model to start with
det_formula <- ~ 1 #scale(HerbaceousUnderstoryCover)
```

## Camera locations 

```{r CamLocs}
cams_curated <- tbl(con, dbplyr::in_schema("camtrap", "curated_camtrap_operation")) %>%
  dplyr::filter(ProjectShortName %in% !!project_short_name) %>% # Only retrieve cam records for hog deer 2023
  dplyr::collect() %>%
  dplyr::arrange(SiteID)
```


## Create model data 

Using the `prepare_model_data()` function we generate the data for the `STAN` model. 

```{r ModelData}
model_data_file <- "data/model_data.rds"
if(!file.exists(model_data_file)) {
evaluate_transects <- c(TRUE, TRUE, TRUE, TRUE, FALSE)
model_data <- list()
for(i in 1:length(deer_species_all)) {
model_data[[i]] <- prepare_model_data(species = deer_species_all[i],
                                 projects = project_short_name,
                     buffer = spatial_buffer,
                     detection_formula = det_formula,
                     abundance_formula = ab_formula,
                     transect_formula = transect_formula,
                     con = con,
                     raster_dir = raster_files,
                     prediction_raster = prediction_raster,
                     n_max_no_det = n_max_no_det,
                     n_max_det = n_max_det,
                     evaltransects = evaluate_transects[i],
                     snapshot_interval = 2)

}
names(model_data) <- deer_species_all
saveRDS(model_data, model_data_file)
} else {
  model_data <- readRDS(model_data_file)
}
```

## Model settings  

```{r ModelSettings}
#### Run models for all species ####
# STAN settings
ni <- 250
nw <- 250
nt <- 1
nb <- 300
nc <- 6
```

# Models  

## Read in Models  

```{r models, echo = FALSE, warning=FALSE}
model_negbin_co <- cmdstan_model(here::here("stan", "count_only_negbin_gp.stan"))
model_negbin <- cmdstan_model(here::here("stan", "count_det_nondet_negbin_gp.stan"))
model_poisson <- cmdstan_model(here::here("stan", "count_det_nondet_poisson_gp.stan"))
model_poisson_co <- cmdstan_model(here::here("stan", "count_only_poisson_gp.stan"))
```

## Fit models  

```{r FitModels, eval = FALSE}
distributions <- c("negbin", "poisson")
model_fits <- list()

for(j in 2:length(distributions)) {

  for(i in 2:length(deer_species_all)) {

  if(evaluate_transects[i]) {
    model_to_fit <- get(paste0("model_", distributions[j]))
  } else {
    model_to_fit <- get(paste0("model_", distributions[j], "_co"))
  }
    
    # Inits for model. 
# inits = lapply(1:nc, function(x) list(beta_det = as.array(runif(model_data[[i]][["det_ncb"]])), 
#                                       beta_trans_det = as.array(rnorm(model_data[[i]][["trans_det_ncb"]], sd = 2)),
#                                       activ = rbeta(1, 
#                                                     shape1 = model_data[[i]][["bshape"]], 
#                                                     shape2 = model_data[[i]][["bscale"]]),
#                                       alpha = runif(1), 
#                                       rho=runif(1),
#                                       eta = rnorm(model_data[[i]][["n_site"]]), 
#                                       eps_ngs=rep(1/model_data[[i]][["n_gs"]], model_data[[i]][["n_gs"]]), 
#                                       beta_psi=runif(model_data[[i]][["m_psi"]]), 
#                                       reciprocal_phi = 1))

  model_fits[[i]] <- model_to_fit$sample(data = model_data[[i]],
                                         chains = nc,
                                 parallel_chains = nc, 
                                 # init = inits, 
                                 max_treedepth = 14,
                                 # adapt_delta = 0.9,
                                 show_messages = TRUE,
                                 save_warmup = FALSE,
                                 iter_sampling = ni, 
                                 iter_warmup = nw)

  model_fits[[i]]$save_object(paste0("outputs/models/fit_", 
                                     distributions[j], 
                                     "_", 
                                     deer_species_all[i],".rds"))

  }
  
}
```

```{r ReadInModels}
model_fits <- list()

model_dir <- "outputs/models"
models_to_read <- list.files(model_dir, full.names = FALSE)

for(i in 1:length(models_to_read)) {
  model_fits[[i]] <- readRDS(paste0(model_dir, "/", models_to_read[i]))
}

names(model_fits) <- stringr::str_replace_all(models_to_read, pattern = ".rds", replacement = "")
```

## Model Evaluation  

### LOO (Leave-One-Out Cross-Validation). 

```{r}
loo_compares <- list()
loo_compare_tables <- list()
for(i in 2:length(deer_species_all)) {
  which_models <- model_fits[stringr::str_detect(models_to_read, pattern = deer_species_all[i])]
  
  loo_compares[[i]] <- list()
  
  for(j in 1:length(which_models)) {
     loo_compares[[i]][[j]] <- which_models[[j]]$loo()
  }
  
  names(loo_compares[[i]]) <- names(which_models)
  loo_compare_tables[[i]] <- loo::loo_compare(loo_compares[[i]]) %>% as.data.frame()
  loo_compare_tables[[i]]$Species <- deer_species_all[i]
}

names(loo_compare_tables) <- deer_species_all[1:2]

loo_table_all <- bind_rows(loo_compare_tables) %>%
        tibble::rownames_to_column(var = "model_full") %>%
  mutate(model = stringr::str_extract(model_full, "poisson|negbin")) %>%
        dplyr::select(Species, model, everything(), -model_full) %>%
        arrange(Species) %>% 
        as.data.frame()

# Plot loo table
  gt(loo_table_all, 
     groupname_col = "Species") %>% 
    fmt_number(decimals = 2) %>%
    tab_style(locations = cells_row_groups(), style = cell_text(weight = "bold"))
    
```

### Posterior predictive checks  

#### All Deer Model. 

```{r ppcAll, fig.width = 6, fig.height = 6, message = F}
funs <- c(prop_zero, mean, max, sd)
titles <- c("Proportion zeros", "Mean", "Max", "SD")

ppc_all <- list()

for(i in 1:length(funs)) {
ppc_all[[i]] <- posterior_checks(model = model_fits[["fit_negbin_All deer"]], 
                 model_data = model_data$`All deer`, 
                 stat = funs[[i]], 
                 integrated = T,
                 title = titles[i])
}

cowplot::plot_grid(plotlist = ppc_all)
```

#### Sambar Deer Model. 

```{r ppcSambar, fig.width = 6, fig.height = 6, message = F}
q95 <- function(x) quantile(x, 0.95)
funs <- c(prop_zero, mean, max, sd)
titles <- c("Proportion zeros", "Mean", "Max", "SD")

ppc_sambar <- list()

for(i in 1:length(funs)) {
ppc_sambar[[i]] <- posterior_checks(model = model_fits[["fit_poisson_Cervus unicolor"]], 
                 model_data = model_data$`Cervus unicolor`, 
                 stat = funs[[i]], 
                 integrated = T,
                 title = titles[i])
}

cowplot::plot_grid(plotlist = ppc_sambar)
```

#### Fallow Deer Model  

```{r ppcFallow, fig.width = 6, fig.height = 6, message = F}
funs <- c(prop_zero, mean, max, sd)
titles <- c("Proportion zeros", "Mean", "Max", "SD")

ppc_fallow <- list()

for(i in 1:length(funs)) {
ppc_fallow[[i]] <- posterior_checks(model = model_fits[["fit_poisson_Dama dama"]], 
                 model_data = model_data$`Dama dama`, 
                 stat = funs[[i]], 
                 integrated = T, only_det = F,
                 title = titles[i])
}

cowplot::plot_grid(plotlist = ppc_fallow)
```

#### Red Deer Model  

```{r ppcRed, fig.width = 6, fig.height = 6, message = F}
funs <- c(prop_zero, mean, max, sd)
titles <- c("Proportion zeros", "Mean", "Max", "SD")

ppc_red <- list()

for(i in 1:length(funs)) {
ppc_red[[i]] <- posterior_checks(model = model_fits[["fit_poisson_Cervus elaphus"]], 
                 model_data = model_data$`Cervus elaphus`, 
                 stat = funs[[i]], 
                 integrated = F, only_det = F,
                 title = titles[i])
}

cowplot::plot_grid(plotlist = ppc_red)
```

#### Hog Deer Model  

```{r ppcRed, fig.width = 6, fig.height = 6, message = F}
funs <- c(prop_zero, mean, max, sd)
titles <- c("Proportion zeros", "Mean", "Max", "SD")

ppc_hog <- list()

for(i in 1:length(funs)) {
ppc_hog[[i]] <- posterior_checks(model = model_fits[["fit_poisson_Axis porcinus"]], 
                 model_data = model_data$`Axis porcinus`, 
                 stat = funs[[i]], 
                 integrated = F, only_det = F,
                 title = titles[i])
}

cowplot::plot_grid(plotlist = ppc_hog)
```


## Model Predictions

```{r}
#### Generate Statewide Predictions ####
#### Make predictions ####
# selected model fits 
model_fits_select <- model_fits[stringr::str_detect(names(model_fits), "poisson")]

gp_preds_draws_all <- list()
pred_raster_means <- list()
for(i in 1:length(model_fits_select)) {
  
  is_negbin <- stringr::str_detect(names(model_fits_select)[i], "negbin")

m_psi <- 1 + length(labels(terms(ab_formula))) # add intercept
n_site <- model_data[[i]]$n_site

# coordinates
coords_pred_scaled <- model_data[[i]]$coords_pred
coords <- model_data[[i]]$coords

obs_gp_function_posterior <-  model_fits_select[[i]]$draws('gp_predict',format = "df")[,1:n_site]  # gp covariance estimates
rho_posterior <- model_fits_select[[i]]$draws('rho', format = "df")$rho        # length scale
alpha_posterior <- model_fits_select[[i]]$draws('alpha', format = "df")$alpha  # marginal variance
beta_posterior<- model_fits_select[[i]]$draws('beta_psi', format = "df")[,1:m_psi] |> as.matrix()  # fixed effects
# phi_posterior <- model_fits_select[[i]]$draws('phi', format = "df")$phi

nsims <- 1
iters <- sample(nrow(beta_posterior),
                size = nsims)

pred_raster_full <- terra::rast(prediction_raster)

Xpred_full <- model_data[[i]]$X_pred_psi

#Split predictions into chunks
chunks <- 10
pred_rows <- nrow(Xpred_full)

split_chunks <- function(x,n) split(1:x, cut(seq(1:x), n, labels = FALSE))

pred_chunks <- split_chunks(pred_rows, chunks)

gp_preds_draws <- list()

for(j in 1:chunks) {

  cat("Starting chunk", i, "at", as.character(Sys.time()))

  pred_grid <- pred_raster_full[pred_chunks[[j]],]

  # pred_grid # prediction grid including covariates
  OS<- rep(4, length(pred_chunks[[j]]))   # offset (cell size)
  Xpred <- Xpred_full[pred_chunks[[j]],]

  obs_distances <- calc_point_distances(coords)
  pred_distances <- calc_point_distances(coords_pred_scaled[pred_chunks[[j]],]) #, upper=TRUE, diag=TRUE)
  obs_to_pred_distances <- calc_point_distances(coords, coords_pred_scaled[pred_chunks[[j]],])

  gp_preds <- bettermc::mclapply(X = as.list(iters),
                                 FUN = predict_gp, obs_distances = obs_distances,
                                 pred_distances = pred_distances,
                                 obs_to_pred_distances = obs_to_pred_distances,
                                 obs_gp_function = obs_gp_function_posterior,
                                 alpha = alpha_posterior,
                                 rho_posterior,
                                 beta = beta_posterior,
                                 Xpred = Xpred,
                                 OS = OS,
                                 dist = "poisson",
                                 # phi = phi_posterior,
                                 mc.progress = TRUE,
                                 mc.cores = 4,
                                 kernel = "quad")

  gp_preds_draws[[j]] <- do.call(cbind, gp_preds) %>%
    as.data.frame()
}

gp_preds_draws_all[[i]] <- dplyr::bind_rows(gp_preds_draws)
saveRDS(gp_preds_draws_all[[i]], paste0("outputs/preds/gp_preds_draws_",deer_species_all[i],".rds"))

pred_raster_means[[i]] <- terra::app(pred_raster_full[[stringr::str_remove_all(labels(terms(ab_formula)), "scale[(]|[)]|sqrt[(]")]], mean)
terra::values(pred_raster_means[[i]])[!is.na(terra::values(pred_raster_means[[i]]))] <- apply(gp_preds_draws_all[[i]], 1, mean, na.rm = T)
terra::writeRaster(pred_raster_means[[i]], paste0("outputs/rasters/pred_mean_",deer_species_all[i],".tif"), overwrite = TRUE)

}
```

