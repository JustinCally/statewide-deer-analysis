---
title: "Abundance of Deer in Victoria"
description: |
  Determining abundance of deer species in Victoria using camera trap data
author:
  - name: Justin G Cally
    url: https://justincally.github.io/blog/
    affiliation: Arthur Rylah Institute
    affiliation_url: https://www.ari.vic.gov.au/
date: 2023-07-06
output:
  html_document:
    self_contained: true
    toc: true # table of content true
    toc_float: true # make 
    depth: 3  # upto three depths of headings (specified by #, ## and ###)
    number_sections: false  ## if you want number sections at each table header
    code_folding: true # awesome buttons to show/hide the code
    theme: yeti
slug: statewidedeer
---

# Setup  

```{r setup, include=TRUE, warnings = FALSE, message=FALSE}
library(cmdstanr)
library(dplyr)
library(sf)
library(bayesplot)
library(loo)
library(gt)
library(terra)
library(caret)
check_cmdstan_toolchain(fix = TRUE, quiet = TRUE)
options(mc.cores=6)

#### Database connection ####
con <- weda::weda_connect(password = keyring::key_get(service = "ari-dev-weda-psql-01",
                                                username = "psql_user"), username = "psql_user")
```


# Custom Functions  

Additional functions used in the data preparation, modelling and analysis are available in the `/functions` directory.  

```{r sourcefunctions, results = 'hide', echo =FALSE, message=FALSE}
# Source internal functions
sapply(list.files("functions", full.names = T), source, verbose = F)
```

# Prepare Data  

## Scope of models 

```{r data_params}
# Species to run model for.
deer_species_all <- c("Cervus unicolor", "Dama dama", "Cervus elaphus", "Axis porcinus")
# Projects to select.
project_short_name <- c("hog_deer_2023", "StatewideDeer")
# Buffer for data extraction.
spatial_buffer <- 1000
# Covariate Rasters
raster_files <- "/Volumes/DeerVic\ Photos/Processed_Rasters"
# raster_files <- "data/prediction_raster"
prediction_raster <- "data/prediction_raster/statewide_raster.tif"
n_max_no_det <- 15
n_max_det <- 50
```

## Camera locations 

```{r CamLocs}
cams_curated <- tbl(con, dbplyr::in_schema("camtrap", "curated_camtrap_operation")) %>%
  dplyr::filter(ProjectShortName %in% !!project_short_name) %>% # Only retrieve cam records for hog deer 2023
  dplyr::collect() %>%
  dplyr::arrange(SiteID) %>%
  sf::st_as_sf(., coords = c("Longitude", "Latitude"), crs = 4283) 
```

## Formulas for detection and abundance. 

```{r formulas}
#### Model formulas ####

#### Transect Formula: Survey Only ####
transect_formula <- ~Survey

#### Abundance Formula Options #### 

# Complex Formula
ab_formula <- ~ scale(BIO04) + scale(BIO06) + scale(BIO15) + scale(sqrt(BareSoil)) + scale(NonPhotosyntheticVeg) + scale(sqrt(MRVBF)) + scale(Nitrogen) + scale(sqrt(PastureDistance)) + scale(sqrt(SLOPE)) + scale(TreeDensity) + scale(sqrt(ForestEdge)) + scale(sqrt(SLOPE) * BIO04) + scale(sqrt(ForestEdge) * BIO06) + scale(BIO15 * sqrt(BareSoil)) 

# Simple Formula: Best for 
ab_formula_2 <- ~ scale(sqrt(BareSoil)) + scale(Nitrogen) + scale(PastureDistance) + scale(TreeDensity) + scale(sqrt(ForestEdge))

# Simple with Climate: Useful for Sambar Deer 
ab_formula_3 <- ~ scale(sqrt(BareSoil)) + scale(sqrt(Nitrogen)) + scale(sqrt(PastureDistance)) + scale(TreeDensity) + scale(sqrt(ForestEdge)) + scale(dist_coast) 

# Simple Formula With Climate and Coastal 
ab_formula_4 <- ~ scale(BareSoil) + scale(sqrt(Nitrogen)) + scale(sqrt(PastureDistance)) + scale(TreeDensity) + scale(sqrt(ForestEdge)) + scale(BIO12) + scale(I(BIO12^2)) + scale(dist_coast) 

det_formula <- ~ scale(HerbaceousUnderstoryCover) # average detection across all sites #scale(HerbaceousUnderstoryCover)
det_formula2 <- ~1
```


## Create model data 

Using the `prepare_model_data()` function we generate the data for the `STAN` model. 

```{r ModelData}
model_data_file <- "data/model_data.rds"
if(!file.exists(model_data_file)) {
evaluate_transects <- c(TRUE, TRUE, TRUE, TRUE)
model_data <- list()
for(i in 1:length(deer_species_all)) {
  
  if(deer_species_all[i] == "Cervus elaphus") {
    det_to_use <- det_formula2
  } else {
    det_to_use <- det_formula
  }
  
model_data[[i]] <- prepare_model_data(species = deer_species_all[i],
                                 projects = project_short_name,
                     buffer = spatial_buffer,
                     detection_formula = det_to_use,
                     abundance_formula = ab_formula_3,
                     transect_formula = transect_formula,
                     con = con,
                     raster_dir = raster_files,
                     prediction_raster = prediction_raster,
                     n_max_no_det = n_max_no_det,
                     n_max_det = n_max_det,
                     evaltransects = evaluate_transects[i],
                     snapshot_interval = 2, 
                     hs_df = 1,
                     hs_df_global = 1,
                     hs_scale_global = 2/sqrt(nrow(cams_curated)), # ratio of expected non-zero to zero divided by total observation as per brms convention
                     hs_scale_slab = 1,
                     hs_df_slab = 4)

}
names(model_data) <- deer_species_all
saveRDS(model_data, model_data_file)
} else {
  model_data <- readRDS(model_data_file)
}

# for(i in 1:3) {
# model_data[[i]]$m_psi <- 6
# model_data[[i]]$X_psi <- model_data[[i]]$X_psi[,-c(7)]
# model_data[[i]]$X_pred_psi <- model_data[[i]]$X_pred_psi[,-c(7)]
# }
# # 
# model_data[[4]]$m_psi <- 7
# model_data[[4]]$X_psi <- model_data[[4]]$X_psi[,c(1:6,9)]
# model_data[[4]]$X_pred_psi <- model_data[[4]]$X_pred_psi[,c(1:6,9)]
```

## Model settings  

Below we list the MCMC setting for our model. We run models on eight parallel chains for 600 iterations each (300 warmup and 300 sampling). These setting provide us with 2,400 posterior draws (8 x 300).


```{r ModelSettings}
# STAN settings
ni <- 250 # sampling iterations
nw <- 250 # warmup iterations 
nc <- 8 # number of chains
```

# Models  

## Read in Models  

```{r models, echo = FALSE, warning=FALSE}
model_poisson <- cmdstan_model(here::here("stan", "count_det_nondet_poisson_hs.stan"))
```

## Fit models  

We can fit models using `cmdstanr`. Here we fit five models using a poisson distribution. One model for each of the four deer species as well as a model for 'all/any deer species'. 

```{r FitModels, eval = FALSE}
distributions <- c("poisson")
model_fits <- list()

for(j in 1:length(distributions)) {

  for(i in 1:length(deer_species_all)) {

  if(evaluate_transects[i]) {
    model_to_fit <- get(paste0("model_", distributions[j]))
  } else {
    model_to_fit <- get(paste0("model_", distributions[j], "_co"))
  }

  model_fits[[i]] <- model_to_fit$sample(data = model_data[[i]],
                                         chains = nc,
                                 parallel_chains = nc, 
                                 init = 0.1, 
                                 max_treedepth = 10, 
                                 refresh = 20, 
                                 step_size = 0.001, 
                                 adapt_delta = 0.999,
                                 show_messages = TRUE,
                                 save_warmup = FALSE,
                                 iter_sampling = ni, 
                                 iter_warmup = nw)

  model_fits[[i]]$save_object(paste0("outputs/models/fit_", 
                                     distributions[j], 
                                     "_", 
                                     deer_species_all[i],".rds"))

  }
  
}
```

```{r ReadInModels}
model_fits <- list()

model_dir <- "outputs/models"

for(i in 1:length(deer_species_all)) {
  model_fits[[i]] <- readRDS(paste0(model_dir, "/fit_negbin_", deer_species_all[i], ".rds"))
}

names(model_fits) <-  paste0("fit_poisson_", deer_species_all)
```

## Model Evaluation  

### LOO (Leave-One-Out Cross-Validation). 

```{r, eval=FALSE}
loo_compares <- list()
loo_compare_tables <- list()
for(i in 2:length(deer_species_all)) {
  which_models <- model_fits[stringr::str_detect(models_to_read, pattern = deer_species_all[i])]
  
  loo_compares[[i]] <- list()
  
  for(j in 1:length(which_models)) {
     loo_compares[[i]][[j]] <- which_models[[j]]$loo(cores = 6)
  }
  
  names(loo_compares[[i]]) <- names(which_models)
  loo_compare_tables[[i]] <- loo::loo_compare(loo_compares[[i]]) %>% as.data.frame()
  loo_compare_tables[[i]]$Species <- deer_species_all[i]
}

names(loo_compare_tables) <- deer_species_all[1:2]

loo_table_all <- bind_rows(loo_compare_tables) %>%
        tibble::rownames_to_column(var = "model_full") %>%
  mutate(model = stringr::str_extract(model_full, "poisson|negbin")) %>%
        dplyr::select(Species, model, everything(), -model_full) %>%
        arrange(Species) %>% 
        as.data.frame()

# Plot loo table
  gt(loo_table_all, 
     groupname_col = "Species") %>% 
    fmt_number(decimals = 2) %>%
    tab_style(locations = cells_row_groups(), style = cell_text(weight = "bold"))
    
```

### Posterior predictive checks  

#### All Deer Model. 

```{r ppcAll, fig.width = 6, fig.height = 6, message = F}
q90 <- function(x) quantile(x, 0.98, na.rm = T)
sd_90 <- function (x, na.rm = FALSE) {
  quants <- quantile(x, c(0.05, 0.95), na.rm = T)
  x <- x[x < quants[2] & x > quants[1]]
  sqrt(var(if (is.vector(x) || is.factor(x)) x else as.double(x), 
    na.rm = na.rm))
}
funs <- c(prop_zero, mean, q90, sd)
titles <- c("Proportion zeros", "Mean", "99% Percentile", "SD (5% - 95%)")

ppc_all <- list()

for(i in 1:length(funs)) {
ppc_all[[i]] <- posterior_checks(model = model_fits[["fit_poisson_All deer"]], 
                 model_data = model_data$`All deer`, 
                 stat = funs[[i]], 
                 integrated = T,
                 title = titles[i])
}

cowplot::plot_grid(plotlist = ppc_all)
```

#### Sambar Deer Model. 

```{r ppcSambar, fig.width = 6, fig.height = 6, message = F}
ppc_sambar <- list()

funs <- c(prop_zero, mean, q95, sd)

for(i in 1:length(funs)) {
ppc_sambar[[i]] <- posterior_checks(model = model_fits[["fit_poisson_Cervus unicolor"]], 
                 model_data = model_data$`Cervus unicolor`, 
                 stat = funs[[i]], 
                 integrated = T, 
                 title = titles[i])
}

cowplot::plot_grid(plotlist = ppc_sambar)

```

#### Fallow Deer Model  

```{r ppcFallow, fig.width = 6, fig.height = 6, message = F}
ppc_fallow <- list()

for(i in 1:length(funs)) {
ppc_fallow[[i]] <- posterior_checks(model = fallow_hu, 
                 model_data = model_data$`Dama dama`, 
                 stat = funs[[i]], 
                 integrated = T, only_det = F,
                 title = titles[i])
}

cowplot::plot_grid(plotlist = ppc_fallow)
```

#### Red Deer Model  

```{r ppcRed, fig.width = 6, fig.height = 6, message = F}
funs <- c(prop_zero, mean, max, sd)
titles <- c("Proportion zeros", "Mean", "Maximum", "SD")

ppc_red <- list()

for(i in 1:length(funs)) {
ppc_red[[i]] <- posterior_checks(model = model_fits[[4]], 
                 model_data = model_data$`Cervus elaphus`, 
                 stat = funs[[i]], 
                 integrated = T, only_det = F,
                 title = titles[i])
}

cowplot::plot_grid(plotlist = ppc_red)
```

#### Hog Deer Model  

```{r ppcHog, fig.width = 6, fig.height = 6, message = F}
funs <- c(prop_zero, mean, q95, sd_90)
titles <- c("Proportion zeros", "Mean", "95% Percentile", "SD (5% - 95%)")

ppc_hog <- list()

for(i in 1:length(funs)) {
ppc_hog[[i]] <- posterior_checks(model = model_fits[["fit_poisson_Axis porcinus"]], 
                 model_data = model_data$`Axis porcinus`, 
                 stat = funs[[i]], 
                 integrated = F, only_det = F,
                 title = titles[i])
}

cowplot::plot_grid(plotlist = ppc_hog)
```


## Model Predictions

```{r PredictionRasters}
pred_raster_full <- terra::rast(prediction_raster)

pred_raster <- terra::app(pred_raster_full[[stringr::str_subset(
  stringr::str_remove_all(labels(terms(ab_formula_2)),
                          "scale[(]|[)]|sqrt[(]"), 
  pattern = "[*]", negate = T)]], mean)

mean_raster <- list()

for(i in 1:length(model_fits)) {

gp_preds_draws_all <- model_fits[[i]]$draws("pred", format = "matrix")

terra::values(pred_raster)[!is.na(terra::values(pred_raster))] <- apply(gp_preds_draws_all, 
                                                                        2, 
                                                                        mean, 
                                                                        na.rm = T, 
                                                                        trim = 0)

mean_raster[[i]] <- pred_raster

# pred_raster_evc <- pred_raster
# values(pred_raster_evc)[!is.na(terra::values(pred_raster_evc))]  <- model_data$`Dama dama`$pred_bioreg
}
```
