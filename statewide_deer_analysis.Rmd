---
title: "Abundance of Deer in Victoria"
description: |
  Determining abundance of deer species in Victoria using camera trap data
author:
  - name: Justin G Cally
    url: https://justincally.github.io/blog/
    affiliation: Arthur Rylah Institute
    affiliation_url: https://www.ari.vic.gov.au/
date: 2023-07-06
output:
  distill::distill_article:
    self_contained: true
    toc: true # table of content true
    toc_float: true # make 
    depth: 3  # upto three depths of headings (specified by #, ## and ###)
    number_sections: false  ## if you want number sections at each table header
    code_folding: true # awesome buttons to show/hide the code
    theme: yeti
slug: statewidedeer
bibliography: bibliography.bib
---

# Methods used to estimate deer density

## Camera detection

The density of deer at a given site can be estimated using camera-trap distance sampling (CTDS). CTDS is a modified form of distance-sampling that allows us to infer the probability a given individual will be detected within the survey area (area in front of the camera). This detection probability is a function of the distance of the individual from the camera, whereby individuals entering the camera field of view further from the camera have a lower detection probability up to a given truncation distance from the camera where detection probability is near-zero.

An underlying assumption about CTDS is that the probability a deer will be available for detection at any given point location within the camera field of view is equal. Under this assumption, for a point transect, we take into account the total area for each distance-bin area, which increases at further distance bins. However, in this study we implement a novel method that considers group size of the detected species in the availability calculations. For larger groups, CTDS should account for the availability of the closest individual rather than the availability of all individuals. When group size increases it is more likely the the closest individual from the group is closer to the camera. If we assume that the triggering of the camera is dependent upon the closest individual than we must adjust our estimated availability to account for variable group sizes. If we do not adjust for group size and only use the distance to the closest individual for our DS models then we will likely underestimate the detection rate as distances will be smaller than reality. Alternatively, if we record distances to multiple individuals in the same photo and take an average or model them independently we would likely overestimate detection probability because individuals at further distances are recorded because a closer individual has triggered the camera trap. For more information on how group size is likely to effect CTDS abundance estimates a simulation study has been written here: <https://justincally.github.io/blog/posts/2022-11-10-ctds-for-groups/>

In this study we investigate two possible detection functions that may explain how detection rates 'fall off' over the distances from the camera. Firstly a half-normal detection function given by:

$$p = exp(-y^2/2\sigma^2) $$ Hereby $p$ is the probability of detection, $y$ is the distance from the camera (midpoint of the detection bin), and $\sigma$ is the shape parameter. Alternatively, we compare the fit of this detection function to a hazard-rate function, where detection probability is given by:

$$p = 1 - exp(-(y/\sigma)^{-\theta})$$ In these hazard-rate models, an additional parameter ($\theta$) is estimated, which is *scale* parameter. Given that detection rate may not necessarily be uniform across sites we model the magnitude of the *shape* parameter across sites (i) as:

$$log(\sigma_i) = \alpha + \beta_{det} \times HU_i$$ Where $HU_i$ is the amount of herbaceous understorey measured surrounding the camera. $\beta_{det}$ is the coefficient for the effect of herbaceous understorey on detection and $\alpha$ is the intercept.

Using these estimates of detection probability in different bins we can then estimate the average detection probability of an individual at a given camera station. This can then be used to account for imperfect detection when fitting observed counts from the camera trap to parameters estimating the true abundance at a site.

## Modelling density

### Modelling abundnace using camera trap data

The density at a site is modelled as a function of the observed counts, relative frequency of group sizes, distance-sampling detection probability, survey effort (area in front of camera x time/snapshot moments the camera is deployed for), proportion of time within a 24-hour cycle that deer were active ($activity$). This parameter was estimated using the `activity` R package and included in the model using an informative beta-distribution prior. For a given species the number of detection's of groups (1 or more deer) during the deployment is estimated with:

$$C_{n,j} = NegBinomial2(exp(log(\lambda_{n}) + log(p_{n,j}) + log(activity) + log(\epsilon gs_{n,j}) + log(\bar p)), \phi_n) \times survey\ area_n$$  
Where $C_{n,j}$ is the observed count of group size ($j$) at a site ($n$). $\lambda_{n}$ is the true density at a site. In this model $X_n$ are the values of the fixed-effect covariates, $\beta$ are the fixed effect coefficients and $\epsilon bioregion_n$ is the bioregion random effect drawn from a standard normal distribution:

$$\lambda_{n} = X_n \times \beta + \epsilon bioregion_n$$ 

The $\epsilon gs_{n,j}$ is the proportional variation in group size ar a site, where $\sum \epsilon gs_{n,j \in [1,max(group\ size)]} = 1$. Assuming that the rate of group sizes can vary between sites, we model the variation in group size between sites with a group-size level intercept ($\zeta_j$) and site-group-size level random effect ($\epsilon site_{n,j}$):

$$\epsilon psi_{nj} = exp(\zeta_j + \epsilon site_{n,j}) $$ 
The proportional group size at a given site and for a given group size is thus given by:

$$\epsilon gs_{nj} = \frac{\epsilon psi_{nj}}{sum(\epsilon psi_{n})}$$ 

We opt for a negative binomial model to account for over-dispersion in counts/abundance. The parameterization of the negative binomial model implemented here ([`NegBinomial2`](https://mc-stan.org/docs/functions-reference/nbalt.html)) contains a mean as expressed by the log-sum of the first five terms. It also contains a dispersion parameter   ($\phi_n$), which is the over-dispersion at the site. $\phi_n$ is modelled as a function of bioregion:  

$$\phi_n = exp(\chi mu_{bioregion_n} + \chi sd_{bioregion_n} \times \chi raw_{bioregion_n})$$

### Supplementing the camera trap data with transect-level data

Our surveys involved the deployment of cameras at a site for usually 6-8 weeks as well as 150m transect searches that were walked up and back by a single individual for two transects, and one transect which was walked once by two observers. This gives us an approximate survey area at each site of 150m x 2 x 3 = 900m. Deer sign was recorded on these transects with pellets, footprints, rubbings, and wallows recorded as either present or absent.

This data provides supplemental presence-absence data that can be integrated into our model to help inform likely densities at sites where cameras did not record observations but one or more deer signs were detected along the transects.

The foundation for this integration is a Royle-Nichols model [@Royle2003] that models the frequency of detection as a mixture of detection probability and abundance. Given that we also collect absolute abundance estimates via the camera trap data, relative abundance measures from this output can be transformed to absolute abundance and thus provide an avenue to integrate camera and transect-based data into a single model estimating abundance. The model can be expressed as: 

$$N_n \sim NegBinomial2(\lambda_n, \bar\phi)$$
Where $\bar\phi$ is the over-dispersion term of the Royle-Nichols component of the model. Conditional detection probability is expressed based on the probability of detection from a given visit/survey type ($j$) (e.g. camera, pellet transect, footprint transect), and the number of individuals available to be detected at the site ($N_n$):  

$$p_{nj} = 1 - (1 - r_{nj}) ^ {N_n}$$
The model for this detection probability is then: 

$$y_{nj} \sim Bernoulli(p_{nj})$$
This model thus allows for $\lambda_n$ to be modelled via the camera counts and the results of detections along the transect.

Finally, the Royle-Nichols model also allows us to estimate the rates at which with camera trap did not detect individuals at a site when they were present. Specifically we can use the average probability of detection of at least one individual at the camera trap, given individuals have expected abundance lambda ($\bar p$).

# Setup

Load in relevant packages for analysis, additionally, connect to the database. Camera trap and site data is stored on the database.

```{r setup, include=TRUE, warnings = FALSE, message=FALSE}
library(cmdstanr)
library(dplyr)
library(sf)
library(bayesplot)
library(loo)
library(gt)
library(terra)
library(caret)
library(tidyterra)
library(tidyr)
library(VicmapR)
library(kableExtra)
library(brms)
library(Distance)
library(ggrepel)
options(brms.backend = "cmdstanr")
check_cmdstan_toolchain(fix = TRUE, quiet = TRUE)
register_knitr_engine(override = FALSE)
options(mc.cores=8)

#### Database connection ####
con <- weda::weda_connect(password = keyring::key_get(service = "ari-dev-weda-psql-01",
                                                username = "psql_user"), username = "psql_user")
```

# Custom Functions

Additional functions used in the data preparation, modelling and analysis are available in the `/functions` directory.

```{r sourcefunctions, results = 'hide', echo =FALSE, message=FALSE}
# Source internal functions
sapply(list.files("functions", full.names = T), source, verbose = F)
```

# Prepare Data

Wrangle and format data for the STAN models for the various species.

## Scope of models

Outline which species should be modeled, and which projects to source data from.

```{r data_params}
# Species to run model for.
deer_species_all <- c("Cervus unicolor", "Dama dama", "Cervus elaphus", "Axis porcinus")
species_names <- c("Sambar Deer", "Fallow Deer", "Red Deer", "Hog Deer")
# Projects to select.
project_short_name <- c("hog_deer_2023", "StatewideDeer")
# Buffer for data extraction.
spatial_buffer <- 1000
# Covariate Rasters
raster_files <- "/Volumes/DeerVic\ Photos/Processed_Rasters"
# raster_files <- "data/prediction_raster"
prediction_raster <- "data/prediction_raster/statewide_raster.tif"
# For the integrated model we place limits on the maximum density of deer to integrate over. In cases where there are no detections on the camera this is limited to 15 per km2. In cases where deer were detected on the camera this is expanded to 50. We believe this is sufficiently high. Very high values of these will be less efficient. 
n_max_no_det <- 15
n_max_det <- 30
```




## Camera locations

Download the camera locations from the database, this table outlines the locations and the deployment history of the cameras.

```{r CamLocs}
cams_curated <- tbl(con, dbplyr::in_schema("camtrap", "curated_camtrap_operation")) %>%
  dplyr::filter(ProjectShortName %in% !!project_short_name) %>% # Only retrieve cam records for hog deer 2023
  dplyr::collect() %>%
  dplyr::arrange(SiteID) %>%
  sf::st_as_sf(., coords = c("Longitude", "Latitude"), crs = 4283) 

n_site <- nrow(cams_curated)
```

## Formulas for detection and abundance

Here we outline formulas to be used in the models. The formulas account for the various fixed-effect parameters.

```{r formulas}
#### Model formulas ####

#### Transect Formula: Survey Only ####
transect_formula <- ~Survey

#### Abundance Formula Options #### 
ab_formula_1 <- ~ scale(sqrt(BareSoil)) + scale(sqrt(Nitrogen)) + scale(log(PastureDistance)) + scale(BIO15) + scale(sqrt(ForestEdge)) + 
  scale(sqrt(MRVBF)) + scale(sqrt(SLOPE)) + scale(sqrt(NonPhotosyntheticVeg))

ab_formula_2 <- ~ scale(sqrt(BareSoil)) + scale(sqrt(Nitrogen)) + scale(log(PastureDistance)) + scale(BIO15) + scale(sqrt(ForestEdge)) + scale(sqrt(MRVBF)) 

ab_formula_3 <- ~ scale(sqrt(BareSoil)) + scale(sqrt(Nitrogen)) + scale(log(PastureDistance)) + scale(BIO15) + scale(sqrt(ForestEdge)) 

ab_formula_4 <- ~ 1

#### Detection Formula: Distance-sampling ####
det_formula <- ~ scale(HerbaceousUnderstoryCover) # average detection across all sites 
```

## Create model data

Using the `prepare_model_data()` function we generate the data for the `STAN` model. This function will:\
1. Download data from the database 2. Format that data to match the distance-sampling bins\
3. Organised the counts into sites and group sizes\
4. Generate model matrix of the various sub-models (distance-sampling, abundance and transect) 5. Generate data for the prediction process 6. Generate data for the random effect (bioregion)\
7. Generate data for regional predictions (indexing based on DEECA regions)

```{r ModelData}
if(!file.exists("data/multispecies_data.rds")) {
  
crown_land <- readRDS("data/crown_land.rds")
  
multispecies_data <- prepare_model_data_multispecies(species = deer_species_all,
                                 projects = project_short_name,
                     buffer = spatial_buffer,
                     detection_formula = det_formula,
                     abundance_formula = ab_formula_1,
                     transect_formula = transect_formula,
                     con = con,
                     raster_dir = raster_files,
                     prediction_raster = prediction_raster,
                     n_max_no_det = n_max_no_det,
                     n_max_det = n_max_det,
                     crown_land = crown_land,
                     evaltransects = TRUE, 
                     filter_behaviour = TRUE)

multispecies_data$keyfun <- 1 # 0 = HN, 1 = HZ
multispecies_data$raw_data[is.na(multispecies_data$raw_data)] <- 0
multispecies_data$transects[is.na(multispecies_data$transects)] <- 0

evc_groups <- readRDS("data/evc_groupnames.rds")

multispecies_data <- c(multispecies_data, evc_groups)

saveRDS(multispecies_data, "data/multispecies_data.rds")
} else {
  multispecies_data <- readRDS("data/multispecies_data.rds")
}
```

# Model Execution

## MCMC settings

Below we list the MCMC setting for our model. We run models on eight parallel chains for 400 iterations each (200 warm-up and 200 sampling). These setting provide us with 1,600 posterior draws (8 x 200).

```{r ModelSettings}
# STAN settings
ni <- 200 # sampling iterations
nw <- 200 # warm-up iterations 
nc <- 8 # number of chains
```



## Read in Models

These are the models used in the analysis. The first is an integrated model that requires transect and camera data. The second is a count-only model that just requires the camera data.

```{cmdstan, file = "stan/count_det_nondet_negbin_ms.stan", output.var = "model_negbin_ms", eval = FALSE}

```

```{cmdstan, file = "stan/count_det_nondet_negbin_ms_evc.stan", output.var = "model_negbin_ms_evc", eval = FALSE}

```

```{r models, echo = FALSE, warning=FALSE}
model_negbin_ms <- cmdstan_model(here::here("stan", "count_det_nondet_negbin_ms.stan"))
model_negbin_ms_evc <- cmdstan_model(here::here("stan", "count_det_nondet_negbin_ms_evc.stan"))
```

## Fit models  

### Detection Models  

Using the distance package we compare several detection functions (hazard and half-normal) with the inclusion of a parameter (herbaceous understorey cover), which may impact detection rates. The top model (as chosen by AIC) from this selection will be included in our full STAN model.  

```{r DetExplore}
filter_behaviour <- TRUE
snapshot_interval <- 2
  # Camera information
  theta <- 40 * pi / 180 # camera angle in radians

  ### Get camera information for the camera sites
  ### For cameras that have problems you need to use the date from when the problem started
  cams_curated2 <- dplyr::tbl(con, dbplyr::in_schema("camtrap", "curated_camtrap_operation")) %>%
    dplyr::filter(ProjectShortName %in% !!project_short_name) %>% # Only retrieve cam records for hog deer 2023
    dplyr::collect() %>%
    dplyr::mutate(DateTimeDeploy = as.POSIXct(DateTimeDeploy),
                  DateTimeRetrieve = as.POSIXct(DateTimeRetrieve),
                  Tk = as.numeric(DateTimeRetrieve - DateTimeDeploy, units = "secs"), #seconds
                  Tk_prob = dplyr::coalesce(as.numeric(as.POSIXct(Problem1_to,
                                                                  format = "%Y-%m-%d %H:%M:%OS") -
                                                         as.POSIXct(Problem1_from, format = "%Y-%m-%d %H:%M:%OS"),
                                                       units = "secs"), 0),
                  Tk_adj = Tk-Tk_prob,
                  Tkt = Tk_adj / snapshot_interval, # snapshot moments: every second second
                  Effort = (Tk_adj*theta)/(snapshot_interval * pi * 2)) %>%
    dplyr::arrange(SiteID)


  ### Get the deer records (hog deer)
  camtrap_records_deer <- dplyr::tbl(con, dbplyr::in_schema(schema = "camtrap", table = "curated_camtrap_records")) %>%
    dplyr::filter(scientific_name %in% deer_species_all & ProjectShortName %in% !!project_short_name) %>%
    dplyr::select(Species = scientific_name, SiteID, Distance = metadata_Distance, size = metadata_Multiples, Date, Time, Behaviour = metadata_Behaviour) %>%
    dplyr::collect() %>%
    dplyr::mutate(Distance = dplyr::case_when(Distance == "NA" | is.na(Distance) ~ "999",
                                              TRUE ~ Distance)) %>%
    dplyr::mutate(Time = as.POSIXct(Time, format = "%H:%M:%OS"),
                  Time_n = as.numeric(Time, units = "secs"),
                  Behaviour = na_if(x = Behaviour, y = "NA")) %>%
    dplyr::rowwise() %>%
    dplyr::mutate(DistanceMod = list(stringr::str_split(Distance, pattern = "_&_")[[1]])) %>%
    dplyr::mutate(Distance = DistanceMod[which.min(as.numeric(stringr::str_extract(DistanceMod, pattern = "[0-9]+")))]) %>%
    dplyr::mutate(Distance = dplyr::case_when(Distance == "0-2.5" ~ "0 - 2.5",
                                              Distance == "999" ~ NA_character_,
                                              TRUE ~ Distance)) %>%
    dplyr::ungroup() %>%
    dplyr::filter(Time_n %% snapshot_interval == 0) %>% #& #snapshot moment interval of 2s
    {if(filter_behaviour) dplyr::filter(., is.na(.data[["Behaviour"]])) else .} %>% # filter out behaviors such as camera or marker interaction
    dplyr::group_by(SiteID, Time_n, Species) %>%
    dplyr::slice(1) %>% # if two photos occur in one second take only one (snapshot moment = 2)
    dplyr::ungroup()

  ### Tidy format for the records
  dcount<- camtrap_records_deer %>%
    dplyr::select(Species, SiteID, Distance, size, Date, Time, Behaviour) %>%
    dplyr::full_join(cams_curated2 %>%
                       dplyr::select(SiteID, Tkt, Effort), by="SiteID") %>%
    dplyr::mutate(object=1:nrow(.)) %>%
    dplyr::mutate(size = if_else(is.na(size),0L, size)) %>%
    dplyr::arrange(SiteID)

  ### Format data in a time format for availability
  summarised_count <- dcount
  summarised_count$Distance <- factor(summarised_count$Distance, levels = c("0 - 2.5", "2.5 - 5", "5 - 7.5", "7.5 - 10", "10+"))
  
  summarised_count <- summarised_count %>%
    mutate(distance = case_when(Distance == "0 - 2.5" ~ 1.25,
                                Distance == "2.5 - 5" ~ 3.75,
                                Distance == "5 - 7.5" ~ 6.25,
                                Distance == "7.5 - 10" ~ 8.75,
                                Distance == "10+" ~ 11.25)) %>%
    filter(size == 1)
  
  # site variables 
    site_vars <- cams_curated2 %>%
    left_join(dplyr::tbl(con, dbplyr::in_schema("deervic", "curated_site_data")) %>%
    dplyr::filter(SiteID %in% !!c(cams_curated2$SiteID, "47191")) %>%
    dplyr::collect() %>%
    dplyr::mutate(HerbaceousUnderstoryCover = scale(NNWHUCover + ENWHUCover),
                  WoodyUnderstoryCover = scale(NWUCover + EWUCover),
                  Trail = factor(Trail),
                  SiteID = dplyr::case_when(SiteID == "47191" & CameraID == "HO04101053" ~ "47191A",
                                            SiteID == "47191" & CameraID != "HO04101053" ~ "47191B",
                                            TRUE ~ SiteID))) %>% # native + exotic herbaceous cover
    dplyr::arrange(SiteID) %>%
    as.data.frame() %>%
      select(-Time, -Tkt, -Date, -Effort) 
    
    ds_data <- summarised_count %>% left_join(site_vars) %>%
      filter(!is.na(HerbaceousUnderstoryCover))
  
  mybreaks <- c(0,2.5,5,7.5,10,12.5)
  trunc.list <- list(left=0, right=12.5)
  conversion <- convert_units("metre", "metre", "metre")
  
  hn0 <- ds(ds_data, transect = "point", key="hn", adjustment = NULL,
          convert_units = conversion, cutpoints = mybreaks, truncation = trunc.list)
  
  hr0 <- ds(ds_data, transect = "point", key="hr", adjustment = NULL,
          convert_units = conversion, cutpoints = mybreaks, truncation = trunc.list)
  
  hn1 <- ds(ds_data, transect = "point", key="hn", adjustment = NULL, 
            formula = ~HerbaceousUnderstoryCover,
          convert_units = conversion, cutpoints = mybreaks, truncation = trunc.list)
  
  hr1 <- ds(ds_data, transect = "point", key="hr", adjustment = NULL, 
            formula = ~HerbaceousUnderstoryCover,
          convert_units = conversion, cutpoints = mybreaks, truncation = trunc.list)
  
  kableExtra::kbl(summarize_ds_models(hn0, hr0, hn1, hr1, output = "latex") %>% 
                    mutate(Model = stringr::str_extract(Model, pattern = '(?<=\\{)[^\\}]+')), 
                  digits=3,
             caption="Model selection table for deer detection", format = "html") %>%
    kable_styling(bootstrap_options = "striped")

```


## Model Options  

Below we list the models we are implementing, all have a hazard detection function, but we compare four different abundance formulas as well as the inclusion of the EVC random effect.  

```{r ModelScope}
#Models to run 
models_to_run <- data.frame(formula = c("ab_formula_1", 
                                        "ab_formula_2",
                                        "ab_formula_3",
                                        "ab_formula_4",
                                        "ab_formula_3", 
                                        "ab_formula_4",
                                        "ab_formula_1",
                                        "ab_formula_2"), 
                            keyfun = c(1,1,1,1,1,1,1,1), 
                            evc = c(F,F,F,F,T,T,T,T))
```

### Full Models  

We can fit models using `cmdstanr`. Here we fit models using a poisson distribution. The models we compare are:

-   Model with several key abundance covariates and half-normal detection function
-   Model with key abundance covariates and hazard-rate detection function
-   Null-model (bioregion only) with half-normal detection function
-   Model with key abundance covariates, bioregion random-effect and an EVC group random effect.  

```{r FitModels, eval = FALSE}
model_fits <- list()

for(i in 1:nrow(models_to_run)) {

  if(models_to_run$evc[i]) {
    model_to_fit <- model_negbin_ms_evc
  } else {
    model_to_fit <- model_negbin_ms
  }
  
  form_to_use <- get(models_to_run$formula[i])
  
  params_to_use <- c(TRUE, labels(terms(ab_formula_1)) %in% labels(terms(form_to_use)))
  
  data_to_use <- multispecies_data
  
  data_to_use$X_psi <- as.matrix(data_to_use$X_psi[,params_to_use])
  data_to_use$X_pred_psi <- as.matrix(data_to_use$X_pred_psi[,params_to_use])
  data_to_use$m_psi <- sum(params_to_use)
  
  data_to_use$keyfun <- models_to_run$keyfun[i]

  model_fits[[i]] <- model_to_fit$sample(data = data_to_use,
                                         chains = nc,
                                 parallel_chains = nc, 
                                 init = 0.1, 
                                 max_treedepth = 10, 
                                 refresh = 25, 
                                 show_messages = TRUE,
                                 show_exceptions = FALSE,
                                 save_warmup = FALSE,
                                 iter_sampling = ni, 
                                 iter_warmup = nw)

  model_fits[[i]]$save_object(paste0("outputs/models/fit_multispecies_", 
                                     i,".rds"))

  
}
```

```{r ReadInModels}
prefix <- "outputs/models/fit_multispecies_"
model_fits <- list()
for(i in 1:nrow(models_to_run)) {
  file_to_read <- paste0(prefix, i, ".rds")
  
  model_fits[[i]] <- readRDS(file_to_read)
}
```

# Model Evaluation

Our strategy for model evaluation is to determine the best performing model out of a limited set of options with different fixed-effects, random-effects and detection functions. 

## LOO (Leave-One-Out Cross-Validation).

We use leave-one-out cross-validation (LOO-CV); a Bayesian model evaluation process [@Vehtari_2017; @loo_2020] to compare the models. Better performing models according to `loo::loo()` will have higher elpd values. 

```{r loo}
loos <- list()
for(i in 1:length(model_fits)) {
  loos[[i]] <- model_fits[[i]]$loo(variables = "log_lik2_species", cores = 8)
}

names(loos) <- paste("model", 1:length(model_fits))

loo_compare_table <- loo::loo_compare(x = loos)

# Plot loo table
  gt(loo_compare_table %>% 
       as.data.frame() %>% 
              tibble::rownames_to_column()) %>% 
    fmt_number(decimals = 2) %>%
    tab_style(locations = cells_row_groups(), style = cell_text(weight = "bold"))
    
```

Given that models are similar in there predictive performance at sampled sites we also evaluate the performance of predictions across unsampled sites. Below we see that more complex models (usually having a slighly better elpd), have poorer performance to unsampled areas and lead to unrealistic predictions. 

```{r varCV}
Nhat_CV <- list()
for(i in 1:length(model_fits)) {
  Nhat_CV[[i]] <- model_fits[[i]]$summary("Nhat", CV = ~ sd(.x)/mean(.x)) %>%
    mutate(Model = i, Species = deer_species_all)
}

Nhat_CV_c <- bind_rows(Nhat_CV)

Nhat_CV_c %>%
  select(Model, Species, CV) %>%
  kbl("html", escape=FALSE, caption = "Coefficients of Variation for Total Abundance estimates for the models assessed in the analysis") %>%
  kable_styling() %>%
  kableExtra::column_spec(3, background = ifelse(Nhat_CV_c$CV > 0.5, "red", ifelse(Nhat_CV_c$CV > 0.2, "orange", "green")), color = "white") %>%
 collapse_rows(1) 
```


## Selecting the 'top' model  

Based on the findings of loo and comparisons of other checks (posterior predictive checks, variation in posterior draws, plausibility of predictions), we see that all model perform similarly well using loo. However, several models produce predictions with lower levels of variation in the posterior predictions. Based on this, we use model 3 hereafter for analysis. This model has fixed effects of `r glue::glue_collapse(labels(terms(ab_formula_3)), sep = ", ", last = " and ")`. It also has a random effect of bioregion for each species and an over-dispersion parameter in the camera counts based on bioregion. This model does not have as many fixed effects as models 1 and 2, and also does not have a second random effect of EVC alongside bioregion (model 6). Unfortunately, the additional random effect of EVC produces much more variable and over-dispersed results for Red Deer, so we opt to use model 3 instead.   

```{r AssignTopModel}
# assign index for top model
top <- 3
```


## Posterior predictive checks

Posterior predictive checks allow us to compare the observed data to the model-generated data. For each species we undertake posterior predictive checks for summary statistics relating to the number of deer seen on the cameras at each site. Ideally a well-fit model is able to make predictions that match the observed data. Here counts are the number of snapshot moments with deer. The summary statistics we use for the posterior predictive checks are:

1.  Maximum counts of deer seen at a site on a camera
2.  Mean number of deer seen at a site on a camera
3.  Standard deviation of the counts of deer on the cameras\
4.  Average (mean) counts at sites in a scatter plot
5.  Proportion of sites with zero counts (camera or transect)  
6.  Observed vs expected proportion of counts   

### Sambar Deer 

Based on the plot below, we see that the PPCs for Sambar perform sufficiently well. 

```{r ppcSambar, fig.width = 6, fig.height = 8, message = F, fig.cap = "Posterior predictive checks for Sambar Deer", warning = FALSE, message = FALSE}
q95 <- function(x) quantile(x, 0.95, na.rm = T)
# q25 <- function(x) quantile(x, 0.25, na.rm = T)
q75 <- function(x) quantile(x, 0.75, na.rm = T)
sd_90 <- function (x, na.rm = FALSE) {
  quants <- quantile(x, c(0.05, 0.95), na.rm = T)
  x <- x[x < quants[2] & x > quants[1]]
  sqrt(var(if (is.vector(x) || is.factor(x)) x else as.double(x),
    na.rm = na.rm))
}

bayes_theme <- c(delwp_cols_seq$Teal[6:8], delwp_cols_shades$Navy[1:3])

bayesplot::color_scheme_set(bayes_theme)

funs <- c(max, mean, sd, ppc_scatter_avg, prop_zero, ppc_dens_overlay)
titles <- c("Max", "Mean", "SD", "Average Site Counts", "Proportion Zeros", "Density of Counts")

ppc_sambar <- list()

# funs <- c(prop_zero, mean, q90, sd)

for(i in 1:length(funs)) {
ppc_sambar[[i]] <- posterior_checks_multispecies(model = model_fits[[top]], 
                 model_data = multispecies_data, species_index = 1,
                 stat = funs[[i]], integrated = T, only_det = F,
                 title = titles[i])
}

cowplot::plot_grid(plotlist = ppc_sambar, labels = "AUTO", ncol = 2)
```

### Fallow Deer 

The PPC's below show that fallow has more dispersion in camera counts than Sambar. While the observed counts fall within the intervals of our model, there is higher uncertainty. Some of these findings appear to be driven by a site with very high counts (over 2000 snapshot moments of deer individuals), this is more than twice the second highest.  

```{r ppcFallow, fig.width = 6, fig.height = 8, message = F, fig.cap = "Posterior predictive checks for Fallow Deer", warning = FALSE, message = FALSE}
ppc_fallow <- list()

for(i in 1:length(funs)) {
ppc_fallow[[i]] <- posterior_checks_multispecies(model = model_fits[[top]], 
                 model_data = multispecies_data, species_index = 2,
                 stat = funs[[i]], integrated = T, only_det = F,
                 title = titles[i])
}

cowplot::plot_grid(plotlist = ppc_fallow, labels = "AUTO", ncol = 2)
```

### Red Deer 

Red Deer have PPC's that show a high congruence between predicted and expected counts.  

```{r ppcRed, fig.width = 6, fig.height = 8, message = F, fig.cap = "Posterior predictive checks for Red Deer", warning = FALSE, message = FALSE}

ppc_red <- list()

for(i in 1:length(funs)) {
ppc_red[[i]] <- posterior_checks_multispecies(model = model_fits[[top]], 
                 model_data = multispecies_data, species_index = 3,
                 stat = funs[[i]], integrated = T, 
                 title = titles[i])
}

cowplot::plot_grid(plotlist = ppc_red, labels = "AUTO", ncol = 2)
```

### Hog Deer 

Hog Deer have PPC's that show our model performs sufficiently well in explaining the patterns of observed counts.  

```{r ppcHog, fig.width = 6, fig.height = 8, message = F, fig.cap = "Posterior predictive checks for Hog Deer", warning = FALSE, message = FALSE}

ppc_hog <- list()

for(i in 1:length(funs)) {
ppc_hog[[i]] <- posterior_checks_multispecies(model = model_fits[[top]], 
                 model_data = multispecies_data, species_index = 4,
                 stat = funs[[i]], integrated = T,
                 title = titles[i])
}

cowplot::plot_grid(plotlist = ppc_hog, labels = "AUTO", ncol = 2)
```

## Model Convergence   

We observed no divergences or any STAN sampling warnings/issues for our models. To visualise the convergence of the model we can observe the mixing of chains for key parameters below:  

+ `beta_det`: Parameters for the distance sampling model (intercept and herbaceous understorey)  
+ `beta_psi`: Parameters for the fixed effect abundance model  
+ `bioregion_sd`: Parameter for the bioregion random effect standard deviation  
+ `odRN`: Parameter for the over-dispersion in the Royle-Nichols negative binomial model  
+ `od_mu`: Parameters for the mean over-dispersion for each species for the camera counts (combined with odRN).   

```{r convergence, fig.width = 10, fig.height = 20, fig.cap="Chain mixing of several key parameters relating to detection, abundance and dispersion"}
bayesplot::color_scheme_set(unname(delwp_cols[1:6]))
convergence_params <- model_fits[[top]]$draws(c("beta_det", 
                                                "beta_psi",
                                                "bioregion_sd", 
                                                "beta_trans_det", 
                                                "odRN", 
                                                "od_mu"))

mcmc_trace(convergence_params, facet_args = list(ncol = 4)) + 
  theme(panel.spacing = unit(0.5, "lines"))
```

# Model Predictions

Within the STAN model we generate predictions for sampled and un-sampled locations. This provides us with site-level abundance estimates as well as estimates across all (un-sampled) public forest.

## Site-based Predictions

### Site-based Detections Map  

Below we display a detection/non-detection map for all sites. 

```{r SiteDetections, fig.height = 16, fig.width=24, fig.cap="Detections of deer (camera or transects) from across Victoria. Detections of Hog Deer are restricted to Gippsland."}
vic_regions <- vicmap_query("open-data-platform:delwp_region") %>%
  collect() %>%
  st_transform(3111) %>%
  st_simplify(dTolerance = 500)

delwp_pal <- colorRampPalette(c("#B9C600",
                                delwp_cols[["Teal"]], 
                                delwp_cols[["Navy"]]))

site_detection_plot <- function(data, regions, cams_curated, species_index) {
  
  cam_data <- cams_curated %>% dplyr::select(SiteID)
  
  cam_data$Detected <- factor(data$any_seen[species_index, ])
  cam_data$cam_seen <- factor(as.integer(as.logical(rowSums(data$n_obs[,,species_index]))))
  
  if(species_index == 4) {
    regions <- regions %>% filter(delwp_region == "GIPPSLAND")
    cam_data <- cam_data %>% st_filter(regions %>% st_transform(4283))
  }
  
   lvls <- length(unique(cam_data$Detected, na.rm = T))
  
plot <- ggplot2::ggplot(data = cam_data) +
  ggplot2::geom_sf(data = regions, alpha = 0.75, fill = "grey80") +
  ggplot2::geom_sf(aes(fill = Detected), shape = 21, size = 2, alpha = 0.75) +
  ggplot2::scale_fill_manual(values = delwp_pal(lvls), 
                             na.value = "transparent", na.translate = F,
                             name = "Detected", guide = guide_legend(override.aes = list(size = 6))) +
  # ggtitle(species_names[species_index])+
  theme_bw() +
  theme(legend.text = element_text(size = 18), legend.key.size = unit(1, "cm"),
        title = element_text(size = 20))
  
return(plot)
  
}

detection_plot <- cowplot::plot_grid(site_detection_plot(multispecies_data, regions = vic_regions, cams_curated = cams_curated, species_index = 1),
site_detection_plot(multispecies_data, regions = vic_regions, cams_curated = cams_curated, species_index = 2),
site_detection_plot(multispecies_data, regions = vic_regions, cams_curated = cams_curated, species_index = 3),
site_detection_plot(multispecies_data, regions = vic_regions, cams_curated = cams_curated, species_index = 4), ncol = 2, 
labels = c("A) Sambar Deer", "B) Fallow Deer", "C) Red Deer", "D) Hog Deer"), greedy = TRUE)

ggsave(plot = detection_plot, filename = "outputs/plots/all_detection_plot.png", width = 4800, height = 3200, units = "px", bg = "white")

detection_plot
```


### Site-based Prediction Map

Below we plot visualisations of point-estimates for the various deer species surveyed for in this study.

```{r SiteMap, fig.height = 18, fig.width = 8, fig.cap = "Site-level density estimates for all sites sampled as part of statewide and hog deer surveys. Point-density estimates are from trimmed means of the posterior draws (trimming of the top and bottom 1% of draws)"}
site_preds <- function(model, cams_curated, species_index) {
  
rn_dens <- model$summary("N_site", prob_occ = ~ mean(. > 0), trimmed_mean = ~mean(., trim = 0.025), CV = ~sd(.)/mean(.), posterior::default_summary_measures(), posterior::default_convergence_measures())
  
which_sp <- which(stringr::str_detect(string = rn_dens$variable,
                                         pattern = paste0("N_site\\[",
                                                          species_index)))
  

  density_at_sites_rn <- cbind(cams_curated, rn_dens[which_sp, ])
  
  return(density_at_sites_rn)
}

site_density_plot <- function(densities, regions, species) {
  densities$density <- cut(densities$mean,
                                   breaks = c(0, 0.25, 0.5, 1, 3, 5, 10, max(densities$mean)),
                                   labels = c("< 0.25",
                                                    "0.25 - 0.5", 
                                                    "0.5 - 1", 
                                                    "1 - 3", 
                                                    "3 - 5",
                                                    "5 - 10", 
                                                    "10 +"), include.lowest = T, right = T)
  
  if(species == "Hog") {
    regions <- regions %>% filter(delwp_region == "GIPPSLAND")
    densities <- densities %>% st_filter(regions %>% st_transform(4283))
  }
  
   lvls <- length(unique(densities$density, na.rm = T))
  
plot <- ggplot2::ggplot(data = densities) +
  ggplot2::geom_sf(data = regions, alpha = 0.75, fill = "grey80") +
  ggplot2::geom_sf(aes(fill = density, alpha = mean), shape = 21, size = 3) +
  ggplot2::scale_fill_manual(values = delwp_pal(lvls), 
                             na.value = "transparent", na.translate = F,
                             name = "", guide = guide_legend(override.aes = list(size = 6))) +
  scale_alpha_continuous(range = c(0.5,1), guide = "none") +
  labs(title = paste0('Abundance of ',species ,' Deer'), fill = bquote('Deer per'~km^2)) +
  theme_bw() +
  theme(legend.text = element_text(size = 18), legend.key.size = unit(1, "cm"),
        title = element_text(size = 20))
  
return(plot)
  
}

sambar_preds <- site_preds(model_fits[[top]], cams_curated = cams_curated, species_index = 1)
fallow_preds <- site_preds(model_fits[[top]], cams_curated = cams_curated, species_index = 2)
red_preds <- site_preds(model_fits[[top]], cams_curated = cams_curated, species_index = 3)
hog_preds <- site_preds(model_fits[[top]], cams_curated = cams_curated, species_index = 4)

site_deer_predictions <- list(Sambar = sambar_preds, 
                         Fallow = fallow_preds, 
                         Red = red_preds, 
                         Hog = hog_preds)

saveRDS(site_deer_predictions, "outputs/site_deer_predictions.rds")

cowplot::plot_grid(site_density_plot(sambar_preds, vic_regions, species = "Sambar"),
site_density_plot(fallow_preds, vic_regions, species = "Fallow"),
site_density_plot(red_preds, vic_regions, species = "Red"), 
site_density_plot(hog_preds, vic_regions, species = "Hog"), ncol = 1)
```

Average density estimates varied across sites for all four species. Sambar deer were the most commonly detected species on the camera traps (`r sum(rowSums(multispecies_data$n_obs[,,1]) > 0)`/`r multispecies_data$n_site` sites), and density estimates at sites ranged from `r round(min(site_deer_predictions$Sambar$mean),1)` to `r round(max(site_deer_predictions$Sambar$mean),2)` deer/km^2^, for fallow, fewer site detections (`r sum(rowSums(multispecies_data$n_obs[,,2]) > 0)`), but more variability in site density gave a range between `r round(min(site_deer_predictions$Fallow$mean),2)` and `r round(max(site_deer_predictions$Fallow$mean),2)` deer/km^2^. Red deer were only detected on `r sum(rowSums(multispecies_data$n_obs[,,3]) > 0)` sites with densities ranging from `r round(min(site_deer_predictions$Red$mean),2)` to `r round(max(site_deer_predictions$Red$mean),2)`. Finally, Hog Deer, which were only detected on `r sum(rowSums(multispecies_data$n_obs[,,4]) > 0)` cameras in South Gippsland, had site densities ranging from `r round(min(site_deer_predictions$Hog$mean),2)` to `r round(max(site_deer_predictions$Hog$mean),2)` deer/km^2^.

### Site-density Summaries

As a sanity-check we compare the average modelled densities at sites with (i) no evidence of deer, (ii) evidence of deer present on transects, and (iii) evidence of deer present on cameras. We expect that average densities are generally higher at sites that detected some form of deer than sites that did not detect any sign of deer. Additionally, we would also expect average densities to be generally higher at sites that had detections on cameras than those with only detections from transects. The table below shows these expectations to be correct.

```{r siteSummary, warning = FALSE, message = FALSE}
density_summary_table <- function(preds, model_data, species, species_index) {
  
  cam_seen <- as.integer(as.logical(rowSums(model_data$n_obs[,,species_index])))
  
  transect_seen <- model_data$transects %>%
    filter(Species == !!deer_species_all[species_index]) %>%
    mutate(NoCam = case_when(Survey == "Camera" ~ 0L, 
                             TRUE ~ 1)) %>%
    group_by(SiteID) %>%
    summarise(TransectDet = max(NoCam*Presence)) %>%
    pull(TransectDet)
  
  preds_sum <- preds %>% 
    st_drop_geometry() %>%
    mutate(`Species` = species,
           `CameraDetection` = cam_seen, 
           `AnyDetection` = model_data$any_seen[species_index, ], 
           `OnlyTransect`  = transect_seen,
           `Detection` = case_when(CameraDetection == 0 & AnyDetection == 0 ~ "Not seen", 
                                   CameraDetection == 0 & AnyDetection == 1 ~ "Only detected on transects", 
                                   CameraDetection == 1 & OnlyTransect == 0 ~ "Only seen on cameras", 
                                   CameraDetection == 1 & OnlyTransect == 1 ~ "Seen on both camera and transect")) %>%
    group_by(`Species`, `Detection`) %>%
    summarise(`Number of Sites` = n(),
              `Average Density` = mean(mean)) %>%
    ungroup()
  
  return(preds_sum)
}

density_summary <- bind_rows(
  density_summary_table(sambar_preds, multispecies_data, 
                        species = "Sambar", species_index = 1),
  density_summary_table(fallow_preds, multispecies_data, 
                        species = "Fallow", species_index = 2),
  density_summary_table(red_preds, multispecies_data, 
                        species = "Red", species_index = 3),
  density_summary_table(hog_preds, multispecies_data, 
                        species = "Hog", species_index = 4))

density_summary %>%
  kbl(format = "html", digits = 2, caption = "Average (mean) density estimates at the various sites groups of sites") %>%
  kable_styling("striped") %>%
  collapse_rows(1)
```

## Regional and Statewide Abundance

Within our model we calculate abundance/density for deer in each of the `r round(sum(multispecies_data$prop_pred))` km^2^ of public land. Based on these spatial predictions we can estimate abundance at a regional level (6 DEECA regions) and across the whole state.

### Statewide Maps

Using the model predictions ("pred") for all suitable public land we generate a raster (1km^2^ resolution). We save the average spatial estimates under `outputs/rasters` (tif files) and also provide binned plots (png files) in `outputs/plots`.

```{r PredictionRasters}
pred_raster_full <- terra::rast(prediction_raster)

pred_raster <- terra::app(pred_raster_full[[stringr::str_subset(
  stringr::str_remove_all(labels(terms(ab_formula_1)),
                          "scale[(]|[)]|log[(]|sqrt[(]"), 
  pattern = "[*]", negate = T)]], mean)

mean_raster <- list()
occ_raster <- list()
mean_raster_discrete <- list()

# gp_preds_draws_all <- model_fits[[top]]$draws("pred", format = "matrix")
gp_preds_draws_all <- model_fits[[top]]$draws("pred", format = "matrix")
# gp_preds_summary_all <- model_fits[[top]]$summary("pred", prob_occ = ~ mean(. > 0))


for(i in 1:length(deer_species_all)) {

which_sp <- which(stringr::str_detect(string = colnames(gp_preds_draws_all),
                                         pattern = paste0("pred\\[", i)))

gp_preds_draws_sp <- gp_preds_draws_all[,which_sp]

terra::values(pred_raster)[!is.na(terra::values(pred_raster))] <- apply(gp_preds_draws_sp, 
                                                                        2, 
                                                                        mean, 
                                                                        na.rm = T) #filter out highest draw

mean_raster[[i]] <- pred_raster
mean_raster_discrete[[i]] <- mean_raster[[i]]
max_pred <- max(values(mean_raster[[i]]), na.rm = T)

values(mean_raster_discrete[[i]]) <- cut(values(mean_raster_discrete[[i]]) , 
                                         breaks = c(0,0.25,0.5,1,3,5,10,max_pred), 
                                         include.lowest = T, right = T,
                                         labels = c("< 0.25",
                                                    "0.25 - 0.5", 
                                                    "0.5 - 1", 
                                                    "1 - 3", 
                                                    "3 - 5",
                                                    "5 - 10", 
                                                    "10 +"))

occ_raster[[i]] <- pred_raster
terra::values(occ_raster[[i]])[!is.na(terra::values(occ_raster[[i]]))] <- apply(gp_preds_draws_sp, 2, function(x) sum(x > 0)/length(x))

}

# combine mean rasters together
combined_raster <- rast(mean_raster)
names(combined_raster) <- c("Average Sambar Deer Density (per km2)", 
                            "Average Fallow Deer Density (per km2)", 
                            "Average Red Deer Density (per km2)", 
                            "Average Hog Deer Density (per km2)")

combined_occupancy_raster <- rast(occ_raster)
names(combined_occupancy_raster) <- c("Average Sambar Deer Occupancy Probability", 
                            "Average Fallow Deer Occupancy Probability", 
                            "Average Red Deer Occupancy Probability", 
                            "Average Hog Deer Occupancy Probability")

writeRaster(combined_occupancy_raster, "outputs/rasters/combined_occupancy_raster.tif", overwrite = T)
writeRaster(combined_raster, "outputs/rasters/combined_deer_average_density.tif", overwrite = T)
```

```{r PlotSave, fig.height=24, fig.width=8, fig.cap="Abundance of Sambar, Fallow, Red and Hog Deer across Victoria, dark-grey area reflects area not included in predictions (i.e. not public land)"}
# reg <- VicmapR::vicmap_query("open-data-platform:delwp_region") %>%
#     VicmapR::collect() %>%
#   sf::st_transform(3111) %>%
#   sf::st_simplify(dTolerance = 250) 
state <- VicmapR::vicmap_query("open-data-platform:vmlite_victoria_polygon_su5") %>%
  filter(state != "NSW" & state != "SA" & feature_type_code != "sea") %>%
  VicmapR::collect() %>%
  sf::st_transform(3111)

gippsland <- vic_regions %>% filter(delwp_region == "GIPPSLAND")

plot_abundance <- function(raster, state, species, crop = NULL) {
  
  if(!is.null(crop)) {
    raster <- terra::crop(raster, vect(crop), mask = T)
    state <- crop
  }
  
  lvls <- length(unique(values(raster, na.rm = T)))
  
  plot <- ggplot2::ggplot() +
    ggplot2::geom_sf(data = state, alpha = 1, linewidth = 0.5, fill = "grey90") + 
    tidyterra::geom_spatraster(data = raster, na.rm = T) + 
    # tidyterra::scale_fill_terrain_d(na.translate = FALSE) + 
    ggplot2::scale_fill_manual(values = delwp_pal(lvls), na.value = "transparent", na.translate = F) +
    ggplot2::labs(fill = bquote('Deer per'~km^2), title = paste0("Average Abundance of ", species, " on Victorian Public Land")) + 
    ggspatial::annotation_scale() +
    delwp_theme()
  
  return(plot)
  
} 

sambar_abundance_plot <- plot_abundance(mean_raster_discrete[[1]], 
                                        state = state, 
                                        species = "Sambar Deer")
fallow_abundance_plot <- plot_abundance(mean_raster_discrete[[2]], 
                                        state = state, 
                                        species = "Fallow Deer")
red_abundance_plot <- plot_abundance(mean_raster_discrete[[3]], 
                                     state = state, 
                                     species = "Red Deer")
hog_abundance_plot <- plot_abundance(mean_raster_discrete[[4]], 
                                     state = state, crop = gippsland,
                                     species = "Hog Deer")

ggsave(plot = sambar_abundance_plot, filename = "outputs/plots/sambar_abundance_plot.png", 
       width = 2400, height = 1600, units = "px")
ggsave(plot = fallow_abundance_plot, filename = "outputs/plots/fallow_abundance_plot.png", 
       width = 2400, height = 1600, units = "px")
ggsave(plot = red_abundance_plot, filename = "outputs/plots/red_abundance_plot.png", 
       width = 2400, height = 1600, units = "px")
ggsave(plot = hog_abundance_plot, filename = "outputs/plots/hog_abundance_plot.png", 
       width = 2400, height = 1600, units = "px")

ggsave(plot = cowplot::plot_grid(sambar_abundance_plot, fallow_abundance_plot, red_abundance_plot, hog_abundance_plot, ncol = 2, labels = "AUTO", greedy = F), filename = "outputs/plots/all_abundance_plot.png", width = 4800, height = 3200, units = "px", bg = "white")

cowplot::plot_grid(sambar_abundance_plot, fallow_abundance_plot, red_abundance_plot, hog_abundance_plot, ncol = 1)
```

### Regional Abundance Estimates

For each DEECA region we provide species-level estimates of abundance with 90 % confidence interval. We also calculate the model-based average density within each region based on the abundance and the total area of public land within each region.


```{r RegAbundance}
Nhat_sum <- model_fits[[top]]$summary("Nhat", trimmed_mean = ~mean(., trim = 0.025), CV = ~sd(.)/mean(.), posterior::default_summary_measures(), posterior::default_convergence_measures())

Nhat_all <- model_fits[[top]]$summary("Nhat_sum", trimmed_mean = ~mean(., trim = 0.025), CV = ~sd(.)/mean(.), posterior::default_summary_measures(), posterior::default_convergence_measures())

format_nhat <- function(sp, data = Nhat_sum) {
  fd <- data %>%
    filter(variable == !!paste0("Nhat[", sp, "]"))
  
  paste0("$\\hat N$ = ",
         formatC(fd$trimmed_mean, digits = 0, big.mark = ",", format = "f"), 
        " [90% CI: ", 
        formatC(fd$q5, digits = 0, big.mark = ",", format = "f"), 
        " – ",
        formatC(fd$q95, digits = 0, big.mark = ",", format = "f"),
        "]")
}

reg <- VicmapR::vicmap_query("open-data-platform:delwp_region") %>%
    VicmapR::collect() %>%
    dplyr::group_by(delwp_region) %>%
    dplyr::summarise(geometry = sf::st_combine(geometry)) %>%
    dplyr::ungroup() %>%
    dplyr::mutate(delwp_region_fact = as.integer(factor(delwp_region))) 

abundance_table <- function(model, regions, pred_area, caption, species_index, return_data = F) {
  
  reg <- model$summary("Nhat_reg", prob_occ = ~ mean(. > 0), trimmed_mean = ~mean(., trim = 0.025), posterior::default_summary_measures(), posterior::default_convergence_measures())
  
  which_sp <- which(stringr::str_detect(string = reg$variable,
                                         pattern = paste0("Nhat_reg\\[", species_index)))
  
  regional_abundance <- reg[which_sp,] %>%
    dplyr::bind_rows(model$summary("Nhat", prob_occ = ~ mean(. > 0), trimmed_mean = ~mean(., trim = 0.025), posterior::default_summary_measures(), posterior::default_convergence_measures())[species_index,]) %>% 
    dplyr::mutate(variable = c(regions$delwp_region, "TOTAL"), 
                  `Area km2` = round(c(pred_area, sum(pred_area))), 
                  `Density (mean)` = round(trimmed_mean/`Area km2`, 2), 
                  `Density (5 %)` = round(q5/`Area km2`, 2),
                  `Density (95 %)` = round(q95/`Area km2`, 2)) %>% 
    dplyr::transmute(Region = variable, 
                  `Trimmed Mean` = round(trimmed_mean), 
                  Median = round(median), 
                  SD = round(sd), 
                  MAD = round(mad),
                  `5 %` = round(q5), 
                  `95 %` = round(q95), 
                  `Area km2`,
                  `Density (mean)`,
                  `Density (5 %)`,
                  `Density (95 %)`)
  
  if(return_data) {
    
 if(species_index == 4) {
    regional_abundance <- regional_abundance %>% 
      filter(Region == "GIPPSLAND")
  }
    
    return(regional_abundance %>% 
             mutate(Species = species_names[species_index], across(2:8, ~ formatC(.x, digits = 0, format = "f", big.mark = ",") )) %>%
             select(Species, everything()))
  }
  
  kableExtra::kbl(regional_abundance, digits = 2, format = "html", caption = caption, format.args = list(big.mark = ",")) %>%
    kableExtra::kable_styling("striped") %>%
    kableExtra::column_spec(1, bold = TRUE) %>%
    kableExtra::row_spec(6, hline_after = T) %>%
    kableExtra::row_spec(7, background = "#A5A1B5", color = "black", bold = T, hline_after = T)
}

pred_a_df <- data.frame(pred_reg = multispecies_data$pred_reg, 
                        area = multispecies_data$prop_pred) %>%
  group_by(pred_reg) %>%
  summarise(area = sum(area))

# Save Abundance Table 
all_ab_tab <- bind_rows(abundance_table(model_fits[[top]], regions = reg, pred_area = pred_a_df$area, species_index = 1, return_data = T), 
                        abundance_table(model_fits[[top]], regions = reg, pred_area = pred_a_df$area, species_index = 2, return_data = T),
                        abundance_table(model_fits[[top]], regions = reg, pred_area = pred_a_df$area, species_index = 3, return_data = T), 
                        abundance_table(model_fits[[top]], regions = reg, pred_area = pred_a_df$area, species_index = 4, return_data = T))

write.csv(all_ab_tab, "outputs/tables/regional_abundance_estimates.csv")

abundance_table(model_fits[[top]], regions = reg, pred_area = pred_a_df$area, caption = "Regional estimates of Sambar Deer Density", species_index = 1)
abundance_table(model_fits[[top]], regions = reg, pred_area = pred_a_df$area, caption = "Regional estimates of Fallow Deer Density", species_index = 2)
abundance_table(model_fits[[top]], regions = reg, pred_area = pred_a_df$area, caption = "Regional estimates of Red Deer Density", species_index = 3)
abundance_table(model_fits[[top]], regions = reg, pred_area = pred_a_df$area, caption = "Regional estimates of Hog Deer Density", species_index = 4) 
```

Deer were found to be widely distributed across Victoria. Across approximately `r round(sum(multispecies_data$prop_pred))` km2 of public land we estimate total deer abundance of the four species investigated in this study (Sambar, Fallow, Red and Hog) at `r formatC(Nhat_all$trimmed_mean, digits = 0, big.mark = ",", format = "f")` (90 % CI: `r formatC(Nhat_all$q5, digits = 0, big.mark = ",", format = "f")` - `r formatC(Nhat_all$q95, digits = 0, big.mark = ",", format = "f")`.  Sambar deer were the most populous species across Victoria (`r format_nhat(1)`), followed by Fallow at `r format_nhat(2)`, Red (`r format_nhat(3)`), and Hog (`r format_nhat(4)`). 

# Model Covariates

Our model uses covariates to inform three separate sub-models:

-   A distance-sampling detection process in front of the camera\
-   An imperfect detection/observation model based on the transect methods and the camera survey\
-   An abundance model based on spatially-derived covariates, as well as a bioregion random effect  

The following section explores the effect of these covariates and sub-models on detection and abundance.   

## Detection Processes

At a site, there are two processes that may lead us to not record deer on a camera when in reality they occupy the site (whereby the site is the home range area surrounding the camera.) Firstly, deer may be available for detection and enter the sampling area in front of the camera. However, due to a function of their distance from the camera we fail to detect this individual. Secondly, they may occupy a site (known from transect signs) but never enter the camera field of view, in this case we estimate the various detection rates from the various methods. The detection rate of the camera in this method is regarded as the spatial availability of deer for camera trap sampling.

### Distance-sampling

Below we show the average detection rate for a given group of deer in front of the camera (up to 12.5m). 

```{r AverageDetectionRates}
det_rates <- model_fits[[top]]$summary("p") %>%
  mutate(var = stringr::str_extract(variable, "(?<=\\[).+?(?=\\])")) %>%
  separate(var, into = c("site", "Group Size"), sep = ",")

av_det_rates <- det_rates %>%
  group_by(`Group Size`) %>%
  summarise(mean = mean(mean)) %>%
  ungroup() %>% 
  transmute(`Group Size`, 
            `Average Site Detection Probability` = mean)


av_det_rates %>%
  bind_rows() %>%
  arrange(`Group Size`) %>%
  kbl("html", digits = 3, caption = "Average detection rates for different group sizes") %>%
  kable_styling("striped") %>%
  collapse_rows(1)
```

We can generate detection function plots that show how detection rates fall-off over varying distances. Initial exploration showed that there may be some relationship between herbaceous understorey and detection probability for Sambar Deer. However, when pooled together we see that herbaceous understorey appears to have no effect on detection.  

```{r DistancePlots, fig.cap="Distance-sampling detection process for Deer (group size = 1-5). Herbaceous understorey cover in the area surrounding appears to have some impact on detection probability", fig.width = 8, fig.height = 6, message = FALSE, warning=FALSE}
site_vars <- dplyr::tbl(con, dbplyr::in_schema("deervic", "curated_site_data")) %>%
    dplyr::filter(SiteID %in% !!c(cams_curated$SiteID, "47191")) %>%
    dplyr::collect() %>%
    dplyr::mutate(HerbaceousUnderstoryCover = NNWHUCover + ENWHUCover,
           SiteID = dplyr::case_when(SiteID == "47191" & CameraID == "HO04101053" ~ "47191A",
                              SiteID == "47191" & CameraID != "HO04101053" ~ "47191B",
                              TRUE ~ SiteID)) %>% # native + exotic herbaceous cover
    dplyr::arrange(SiteID) %>%
    as.data.frame()

  n_distance_bins <- 5
  delta <- 2.5
  midpts <- c(1.25, 3.75, 6.25, 8.75, 11.25)
  max_distance <- 12.5
  gs <- 1:5
  
  pa <- matrix(data = NA, nrow = max(gs), ncol = length(midpts))
  for(j in 1:max(gs)) {
    pa[j, ] <- sapply(midpts, function(x) {pr_closest(x-(0.5*delta),
                                                      x+(0.5*delta),
                                                      max_distance = max_distance,
                                                      n = j)})
  }


det_curve <- model_fits[[top]]$draws("DetCurve", format = "draws_matrix") %>%
  as.data.frame() %>%
  # head(250) %>%
  pivot_longer(cols = everything())

det_curve_wr <- det_curve %>%
  mutate(var = stringr::str_extract(name, "(?<=\\[).+?(?=\\])")) %>%
  separate(var, into = c("s", "Distance"), sep = ",") %>%
  mutate(Distance = as.numeric(Distance)-0.5)

det_vars_pred <- site_vars %>%
  mutate(s = as.character(1:nrow(.)),
         herbaceouslvl = cut(HerbaceousUnderstoryCover,
                             breaks = c(0, 25, 50, 75, 105), 
                             labels = c("0 - 25%", 
                                        "25 - 50%", 
                                        "50 - 75%", 
                                        "75 - 100%"),
                             include.lowest = T, right = FALSE))

det_curve_sum <- det_curve_wr %>%
  mutate(Distance = as.numeric(Distance)) %>%
  left_join(det_vars_pred) %>%
  group_by(herbaceouslvl, Distance) %>%
  summarise(median = quantile(value, 0.5),
            q5 = quantile(value, 0.05),
            q95 = quantile(value, 0.95))

scaleHN <- det_curve_sum %>% filter(Distance == 1.5) %>% pull(median) %>% mean() # Approx scaling

y_comb_list <- list()
for(i in 1:max(gs)) {
y_comb_list[[i]] <- colSums(multispecies_data$y[,,i]) %>% 
  as.data.frame() %>%
  `colnames<-`("Count") %>%
  mutate(Distance = midpts,
         Bin = 1:5,
         gs = i,
         Prop = Count/(max(Count)),
         CountS = Count/pa[Bin,i])

}

y_combined <- bind_rows(y_comb_list) %>% 
  group_by(Distance) %>%
  mutate(SumCount = sum(Count)) %>%
  ungroup() %>%
  mutate(propC = Count/SumCount, 
         PropSM = (CountS/max(CountS)) * propC)  %>%
  group_by(Distance) %>% 
  summarise(PropS = sum(PropSM) * scaleHN)

detection_plot_HN <- ggplot(aes(x = Distance), data = det_curve_sum) +
  geom_col(aes(y = PropS), fill = "grey70", colour = "grey20", width = 2.5, data = y_combined, alpha = 0.7) +
  # geom_error bar(aes(ymin = PropSq5, ymax = PropSq95),  data = y_combined) +
  # geom_line(aes(y = HNS)) +
  geom_ribbon(aes(ymin = q5, ymax = q95, fill = herbaceouslvl), alpha = 0.5) +
  geom_line(aes(y = median, colour = herbaceouslvl)) +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0), limits = c(0,1)) +
  scale_fill_manual(values = unname(delwp_cols[c(1,2,3,8)])) +
  scale_colour_manual(values = unname(delwp_cols[c(1,2,3,8)])) +
  ylab("Detection probability (p)") +
  labs(fill = "Herbaceous\nUnderstorey\nCover", colour = "Herbaceous\nUnderstorey\nCover") +
  theme_classic()

ggsave(plot = detection_plot_HN, filename = "outputs/plots/hazard_detection_plot.png", width = 2400, height = 1600, units = "px")

detection_plot_HN
```

### Transect-surveys

For Sambar, Fallow and Red Deer we were able to estimate detection rates of the various methods used to detect deer (camera, footprints, pellets, rubbings and wallows).

```{r detectionplots, fig.width=8, fig.height=5, fig.cap="Unconditional detection probabilities for the various methods of survey, across various deer densities. Camera trap detection probability is based on average deployment length (53 days), while transects are based on 3 transect searches", warnings = FALSE, message = FALSE}
  
all_draws <- model_fits[[top]]$draws("beta_trans_det", format = "df")

# det_marginal_effects <- list()
# det_plot <- list()

obs_vars <- unlist(stringr::str_remove_all(string = labels(terms(transect_formula)), pattern =  "log|scale|\\)|\\("))
obs_cols <- unlist(stringr::str_remove_all(string = colnames(multispecies_data$trans_pred_matrix), pattern =  "log|scale|\\)|\\("))
obs_logs <- unlist(stringr::str_detect(string = colnames(multispecies_data$trans_pred_matrix), pattern =  "log\\("))

obs_labs <- c("Survey Method")

fac <- c(TRUE, TRUE, TRUE, TRUE, TRUE)
fac2 <- c(TRUE)

det_obs <- multispecies_data$transects %>% 
  mutate(Survey = factor(Survey))

det_marginal_effects <- list()
det_plot <- list()

params_w_levs <- levels(det_obs$Survey)

for(i in 1:(length(obs_cols))) {
det_marginal_effects[[i]] <- marginal_effects_cmd(all_draws, 
                                              param = "beta_trans_det", 
                                              param_number = i, log = obs_logs[i],
                                     model_data = det_obs, 
                                     model_column = obs_vars[c(1,attr(multispecies_data$trans_pred_matrix, "assign")[-1])[i]], 
                                     transition = FALSE) %>%
  mutate(group = param, 
         param = params_w_levs[i], 
         factor = fac[i], 
         variable = as.numeric(variable))

if(fac[i]) {
  det_marginal_effects[[i]] <- det_marginal_effects[[i]]
}

}

marginal_prob <- function(x, pwr = 3) {
  xm <- 1-x
  return(1-(xm^pwr))
}

det_marginal_effects_bind <- bind_rows(det_marginal_effects) %>%
  rowwise() %>%
  mutate(value = case_when(param != "Camera" ~ marginal_prob(value), 
                           TRUE ~ value))

det_marginal_effects_split <- split(det_marginal_effects_bind, det_marginal_effects_bind$group)

for(i in 1:length(det_marginal_effects_split)) {
  
  if(fac2[i]) {
    plot_data <- det_marginal_effects_split[[i]] %>% 
      mutate(variable = param, 
             param = group)
  } else {
    plot_data <- det_marginal_effects_split[[i]]
  }

det_plot[[i]] <- plot_data

}
data_for_plot <- bind_rows(det_plot) %>% 
  mutate(species = "All (combined)") %>%
  mutate(Density = "1 deer/km^2^")

data_d3 <- data_for_plot %>% 
  mutate(value = 1 - (1 - value)^3, 
         Density = "3 deer/km^2^")

data_d5 <- data_for_plot %>% 
  mutate(value = 1 - (1 - value)^5, 
         Density = "5 deer/km^2^")

data_combined <- bind_rows(data_for_plot, data_d3, data_d5)

transect_det_plot <- marginal_effects_plot_cmd_all(data_combined, 
                              factor = TRUE,
                              ylab = "Detection probability") +
  xlab("Survey method") +
  scale_y_continuous(limits = c(0,1)) +
  theme(legend.position = "top") +
  scale_fill_manual(values = unname(delwp_cols[c(1,2,3)])) +
  # scale_x_discrete(expand = c(0, 0)) +
  theme_classic() +
  theme(legend.text = ggtext::element_markdown())

ggsave(plot = transect_det_plot, filename = "outputs/plots/transect_detection_plot.png", width = 2400, height = 1400, units = "px")

transect_det_plot

```

## Abundance Processes

### Bioregion

We used a spatially-derived random-effect of the bioregion of the sampled site. This random-effect allows us the ability to make predictions that include the variance associated with this random effect. This random-effect also minimises predictions in areas without deer detection's (e.g. the mallee).  


```{r bioregions, fig.height=24, fig.width = 5, fig.cap="Influence of the bioregion random effect on abundance (log-scale). "}
bioregion_sd <- model_fits[[top]]$summary("bioregion_sd")

bayesplot::color_scheme_set(bayes_theme)
bioregion_contribution <- function(model, data, species, species_index) {
  eps_bioregion <- model$draws("eps_bioregion", format = "matrix")
  
  which_sp <- which(stringr::str_detect(string = colnames(eps_bioregion),
                                         pattern = paste0("eps_bioregion\\[", i)))
  
  eps_bioregion <- eps_bioregion[,which_sp]
  
  bioregion_data <- data[["bioreg_sf"]]
  colnames(eps_bioregion) <- bioregion_data$bioregion
  
  plot <- mcmc_areas(eps_bioregion, prob_outer = 0.9) +
    ggtitle(species)
  
  return(plot)
}

bio_plot_data <- list()

for(i in 1:length(species_names)) {
 bio_plot_data[[i]] <- bioregion_contribution(model = model_fits[[top]], 
                         data = multispecies_data, 
                         species = species_names[i], species_index = i)
} 

cowplot::plot_grid(plotlist = bio_plot_data, ncol = 1)
```

Bioregion usually had a substantial impact on abundance estimates across the state. The variance (standard deviation) associated with the bioregion random effect was large for Sambar ($\sigma$ = `r round(bioregion_sd$mean[1],2)`, 90% CI: `r round(bioregion_sd$q5[1],2)` - `r round(bioregion_sd$q95[1],2)`), but less for Fallow ($\sigma$ = `r round(bioregion_sd$mean[2],2)`, 90% CI: `r round(bioregion_sd$q5[2],2)` - `r round(bioregion_sd$q95[2],2)`). Red Deer also exhibited large variance in the bioregion random effect ($\sigma$ = `r round(bioregion_sd$mean[3],2)`, 90% CI: `r round(bioregion_sd$q5[3],2)` - `r round(bioregion_sd$q95[3],2)`), as well Hog ($\sigma$ = `r round(bioregion_sd$mean[4],2)`, 90% CI: `r round(bioregion_sd$q5[4],2)` - `r round(bioregion_sd$q95[4],2)`). The larger variances for Hog, Red and Sambar reflect their more refined range boundaries, wheras Fallow show less clear range boundaries and thus show less variance across the state.   


<!-- We can also visualise the average densities within each bioregion for the four species:   -->

```{r bioregiondensity, fig.height = 16, fig.width=24, warning = FALSE, fig.cap="Effect of Victorian Bioregions on abundance of deer"}
# Bioregion map 
bioregion_eff <- model_fits[[top]]$summary("eps_bioregion", posterior::default_summary_measures())

bioreg <- VicmapR::vicmap_query("open-data-platform:vbioreg100") %>%
    VicmapR::collect() %>%
  group_by(bioregion, bioregion_code) %>%
  summarise(geometry = st_union(geometry)) %>%
  ungroup()

bioregion_nhat <- model_fits[[top]]$summary("Nhat_bioreg", prob_occ = ~ mean(. > 0), trimmed_mean = ~mean(., trim = 0.025), posterior::default_summary_measures())

bioregion_density <- list()

for(i in 1:length(species_names)) {
  which_sp <- which(stringr::str_detect(string = bioregion_nhat$variable,
                                         pattern = paste0("Nhat_bioreg\\[", i)))
  
  bioregion_nhat_sp <- bioregion_nhat[which_sp,]
  
  bioregion_nhat_sp$bioregion <- multispecies_data$bioreg_sf$bioregion 
  bioregion_nhat_sp$Area <- as.numeric(table(multispecies_data$pred_bioreg))
  
  bioregion_nhat_sp <- bioregion_nhat_sp %>% 
    mutate(`Average Density` = trimmed_mean/Area, 
           `Density (5%)` = q5/Area, 
           `Density (95%)` = q95/Area, 
           `CV` = sd/trimmed_mean, 
           label = paste0(bioregion, " [D = "
                          ,round(`Average Density`,2),
                          " (",round(`Density (5%)`,2)," - ",round(`Density (95%)`, 2),")]"))
  
  bioregion_density[[i]] <- left_join(bioreg, bioregion_nhat_sp, by = "bioregion")
  
}

bioregion_effects <- list()

for(i in 1:length(species_names)) {
  which_sp <- which(stringr::str_detect(string = bioregion_eff$variable,
                                         pattern = paste0("eps_bioregion\\[", i)))
  
  bioregion_eff_sp <- bioregion_eff[which_sp,]
  
  intercept <-  model_fits[[top]]$summary(paste0("beta_psi[",i,",1]"), mean = ~ mean(.))$mean
  
  bioregion_eff_sp$bioregion <- multispecies_data$bioreg_sf$bioregion 
  bioregion_eff_sp$Area <- as.numeric(table(multispecies_data$pred_bioreg))
  
  bioregion_eff_sp <- bioregion_eff_sp %>% 
    mutate(`Average Effect` = mean)
  
  bioregion_effects[[i]] <- left_join(bioreg, bioregion_eff_sp, by = "bioregion")
  
}

bioregion_ggplot <- function(effect_df, title) {
  ggplot(data = effect_df) +
    geom_sf(data = state, linewidth = 0.5, fill = "grey90") +
    geom_sf(aes(fill = `Average Effect`)) +
    geom_label_repel(data = effect_df, aes(label = bioregion, fill = `Average Effect`, geometry = geometry), 
                  size = 2.5, stat = "sf_coordinates", colour = "white") +
    scale_fill_gradient2(low = "#B9C600",
                         mid = delwp_cols[["Teal"]], 
                         high = delwp_cols[["Navy"]], guide = guide_coloursteps(title = "Average Effect\n (log-scale)")) +
    labs(x = "Longitude", y = "Latitude") +
    ggspatial::annotation_scale() +
    delwp_theme()
}

# cl_br <- st_intersection(crown_land, bioreg %>% filter(bioregion == "Bridgewater") %>% st_transform(3111))

cpb <- cowplot::plot_grid(bioregion_ggplot(bioregion_effects[[1]], "Sambar"),
bioregion_ggplot(bioregion_effects[[2]], "Fallow"),
bioregion_ggplot(bioregion_effects[[3]], "Red"),
bioregion_ggplot(bioregion_effects[[4]], "Hog"), labels = c("A) Sambar Deer", "B) Fallow Deer", "C) Red Deer", "D) Hog Deer"), ncol = 2)

ggsave(plot = cpb, filename = "outputs/plots/bioregion_effects_plot.png", width = 4800, height = 3200, units = "px", bg = "white")

cpb
```

```{r, eval = FALSE, include = FALSE}
# site_grid <- st_read(dsn = con,
#                      layer = Id(schema = "deervic", table = "raw_sampling_grid"))
# site_grid_c <- st_read(dsn = con,
#                      layer = Id(schema = "deervic", table = "curated_final_site_selection"))
# 
# site_grid_filter <- site_grid %>% filter(frac_area >= 0.05)
# # load("data/crown_layers_extent.rda")
# crown_land <- readRDS("data/crown_land.rds")
# 
# site_grid_crop <- site_grid_filter %>% 
#   st_intersection(crown_layers_extent)
# 
# grid_vals <-  exactextractr::exact_extract(combined_raster, site_grid_crop, 'sum')
# 
# site_grid_combined <- bind_cols(site_grid_crop, grid_vals)


vic_bound <- vicmap_query("open-data-platform:vmlite_victoria_polygon_su5") %>%
  filter(state == "VIC" ) %>% # Philip Island and French Island
  collect() %>%
  sf::st_simplify(dTolerance = 100) %>%
  sf::st_union() %>%
  sf::st_transform(3111)

# expected area = 2000m * 2000m = 4e+6 m2 = 4 km2
cellarea <- 4e+6
cellsize <- 2 * sqrt(cellarea/((3*sqrt(3)/2))) * sqrt(3)/2

grid <- sf::st_make_grid(x = vic_bound,
                         cellsize = cellsize,
                         square = FALSE)

crown_land2 <- readRDS("data/crown_land.rds") %>%
  st_simplify(dTolerance = 500)

# site_grid_crop <- grid %>% 
#   st_intersection(crown_land2)

combined_raster <- rast("outputs/rasters/combined_deer_average_density.tif")

grid_vals <-  exactextractr::exact_extract(combined_raster, grid, 'sum') %>% `names<-`(species_names)
grid_area <- st_area(grid) %>% units::set_units("km2")

site_grid_combined <-  st_as_sf(grid) %>% 
  bind_cols(grid_vals) %>% 
  st_filter(crown_land2)

mapview::mapview(site_grid_combined, zcol = "Sambar Deer")
```


### Fixed-parameter Effects

```{r FixedEffects, fig.height=7, fig.width = 10, warning = FALSE, message = FALSE, fig.cap="Marginal response curves for the various fixed-effect parameters used in the model."}
# beta_summaries 
beta_summaries <- model_fits[[top]]$summary("beta_psi")

beta_table_summary <- beta_summaries %>% 
  mutate(species = factor(rep(species_names, times = 6),levels = species_names), 
         covariate = rep(c("(Intercept)",
              "Bare Soil (%)", 
              "Nitrogen (%)", 
              "Distance to Pastural Land (m)", 
              "Precipitation Seasonality", 
              'Forest Edge per km^2^ (m)'), each = 4)) %>%
  arrange(species) %>%
  select(species, covariate, mean, sd, q5, q95)

format_cov <- function(sp, b, data = beta_summaries, variable = "beta_psi") {
  fd <- data %>%
    filter(variable == !!paste0(variable, "[", sp, ",",b+1,"]"))
  
  paste0("$\\beta$ = ",
         round(fd$mean, 2), 
        " [90% CI: ", 
        round(fd$q5, 2), 
        " – ",
        round(fd$q95, 2),
        "]")
}

ab_joined_list <- list()
for(j in 1:length(species_names)) {
beta_draws <- model_fits[[top]]$draws("beta_psi", format = "df")

# which_sp <- which(stringr::str_detect(string = colnames(beta_draws),
#                                     pattern = paste0("beta_psi\\[", i)))
# 
# beta_draws <- beta_draws[,which_sp]

ab_marginal_effects <- list()
ab_plot <- list()

ab_to_use <- ab_formula_3

phi_vars <- unlist(stringr::str_remove_all(string = labels(terms(ab_to_use)), pattern =  "log|scale|sqrt|\\)|\\("))
phi_logs <- unlist(stringr::str_detect(string = labels(terms(ab_to_use)), pattern =  "log\\("))
phi_sqrts <- c(0.5,0.5,1,1,0.5)

phi_labs <- c("Bare Soil (%)", 
              "Nitrogen (%)", 
              "Distance to Pastural Land (m)", 
              "Precipitation Seasonality", 
              'Forest Edge per km^2^ (m)')

fac <- c(FALSE, FALSE, FALSE, FALSE, FALSE)

for(i in 1:length(phi_vars)) {
ab_marginal_effects[[i]] <- marginal_effects_cmd(beta_draws, 
                                              param = "beta_psi", species_index = j,
                                              param_number = i+1, log = phi_logs[i],
                                     model_data = multispecies_data[["raw_data"]] %>% mutate(Nitrogen = Nitrogen*100), 
                                     abundance = TRUE,
                                     pwr = phi_sqrts[i],
                                     model_column = phi_vars[i], 
                                     transition = FALSE) %>%
  mutate(species = species_names[j])

}
ab_joined_list[[j]] <- bind_rows(ab_marginal_effects)
}

all_me_data <- bind_rows(ab_joined_list) %>%
  mutate(param = case_when(param == "BareSoil" ~ "Bare Soil (%)", 
                           param == "Nitrogen" ~ "Nitrogen (%)", 
                           param == "PastureDistance" ~ "Distance to Pastural Land (m)", 
                           param == "BIO15" ~ "Precipitation Seasonality", 
                           param == "ForestEdge" ~ 'Forest Edge per km^2^ (m)'))
  

cov_plot <- marginal_effects_plot_cmd_all(all_me_data %>% mutate(species = factor(species, levels = species_names), 
                                                     param = factor(param, levels = phi_labs)), 
                          col = "DarkGreen", 
                          factor = FALSE,
                          ylab = "Contribution to Abundance (log-scale)") +
      ggplot2::facet_grid(species~param, scales = "free") +
  delwp_theme() +
  theme(strip.text = ggtext::element_markdown()) +
  xlab("Covariate Value")

ggsave(plot = cov_plot, filename = "outputs/plots/abundance_covariate_effects.png", width = 3000, height = 2000, units = "px")

cov_plot

```

Of the five fixed-effect covariates used in the top model we found that all had tangible effects for one or more species. The direction and magnitude of these effects often varied between species. Bare soil had a slight positive effect on Sambar abundance (`r format_cov(1,1)`), negligible effect on Fallow (`r format_cov(2,1)`) and Red Deer (`r format_cov(3,1)`), and a slight negative effect on Hog Deer abundance (`r format_cov(4,1)`). Nitrogen generally had weaker, more variable effects. The effect of nitrogen was weakly positive for Sambar (`r format_cov(1,2)`), and Hog Deer (`r format_cov(4,2)`); but weakly negative for Fallow (`r format_cov(2,2)`), and Red Deer (`r format_cov(3,2)`). The effect of distance to pasture was consistently negative across all four species, which can also be interpreted as a prefence of deer to be 'closer' to pastural areas. However the effect of this covariate varied in magnitude for Sambar (`r format_cov(1,3)`), Fallow (`r format_cov(2,3)`), Red (`r format_cov(3,3)`), and Hog Deer (`r format_cov(4,3)`). Sambar Deer weakly favored areas with less seasonal variation in precipitation (`r format_cov(1,4)`), with Fallow (`r format_cov(2,4)`), Red (`r format_cov(3,4)`), and Hog Deer (`r format_cov(4,4)`) all showing positive relationships between precipitation seasonality and abundance. Lastly, we saw that the amount of forest edge in the landscape positively impacted abundance for Sambar (`r format_cov(1,5)`), and Fallow Deer (`r format_cov(2,5)`). This relationship was weakly negative for Red Deer (`r format_cov(3,5)`), and weakly positive for Hog Deer (`r format_cov(4,5)`).   

```{r covtable}
which_sig <- which(beta_table_summary$q5 * beta_table_summary$q95 > 0)

write.csv(beta_table_summary, "outputs/tables/beta_coefs.csv")
beta_table_summary %>%
  kbl("html", digits = 3, caption = "beta-coeffiient estimates for the drivers of species abundance, coefficient estimates not-overalpping zero are shown in bold") %>%
  kable_styling("striped") %>%
  collapse_rows(1) %>%
  row_spec(row = which_sig, bold = TRUE)
```


# Additional Parameters of Interest

Below is a table with several model parameters we estimated:  

```{r keyparams}
key_params <- model_fits[[top]]$summary(c("av_gs", 
                                          "od_mu", 
                                          "odRN", 
                                          "activ", 
                                          "Nhat_sum"))

key_params %>% 
  kbl(format = "html", digits = 2, caption = "Several key outputs and parameters of the model not reported earlier") %>%
  kable_styling("striped")
```

### Dispersion  

```{r Dispersion}
dispersion_data <- model_fits[[top]]$summary(c("od", "odRN")) %>%
  mutate(species = c(species_names, "All"), 
         model = c(rep("Camera count", 4), "Royle-Nichols"), 
         parameter = c("$$\\phi_1$$", "$$\\phi_2$$", "$$\\phi_3$$", "$$\\phi_4$$", "$$\\bar \\phi$$")) %>%
  select(model, species, parameter, mean, sd, q5, q95)

format_od <- function(data) {
  paste0(dispersion_data$parameter, " = ", round(dispersion_data$mean, 3), " [90 % CI: ", round(dispersion_data$q5,3), " -- ", round(dispersion_data$q95,3), "]")
}

formatred_od <- format_od(dispersion_data)

dispersion_data %>% 
  kbl("html", digits = 3, caption = "Estimates of the dispersion parameter within negative binomial submodels") %>%
  kable_styling("striped") %>%
  collapse_rows(1)
  
```

Estimates of abundance were also dependent upon overdispersion (excess variation) in the camera counts and transect detections. Sambar (`r formatred_od[1]`), Fallow (`r formatred_od[2]`), Red (`r formatred_od[3]`), and Hog Deer (`r formatred_od[4]`) all had large amounts of overdispersion (where lower values (<1) equate to more variance). The Royle-Nichols model had less variance (than camera counts) associated with transect-level detections/non-detections (`r formatred_od[5]`).  

# Relating abundance to vegetation 

From our point density estimates of deer, we can model relationships between deer densities at sites and a range of structural vegetation measures collected during the surveys. For this part of the analysis we implement a multivariate regression.   

Firstly the response variables we model are: 

+ Bare Ground Cover (Beta Distribution) 
+ Native Woody Understorey Cover (Beta Distribution) 
+ Native Non-woody Understorey Cover (Beta Distribution) 
+ Presence of seedlings (Negative Binomial Distribution) 
+ Presence of saplings (Negative Binomial Distribution) 
+ Presence of exotic flora (Bernoulli Distribution)  

While our main predictor of interest is the density of deer at a site, we also control for predictors that are expected to have an impact on vegetation growth and composition. The predictors controlled for include features relating to climate, ecology, topography, fire history and forest structure. They are the following predictors:  

+ BIO01: Annual Mean Temperature 
+ BIO04: Temperature Seasonality    
+ BIO06: Min Temperature of Coldest Month
+ BIO12: Annual Precipitation    
+ BIO15: Precipitation Seasonality (Coefficient of Variation)  
+ Soil Nitrogen  
+ Time since last fire (factor grouping)  
+ TWIND (Topographic wetness index)  
+ Forest Edge  
+ Canopy Cover  
+ Top Height 
+ EVC Group (random effect with 19 groups)

## Data Preparation  

We can use the sum of estimated deer density for the four species at each site as our key predictor variable. Given that we already extracted a range of bioclimatic and environmental covariates for the original model, we can combine those with the data available here. 

Note that this model is run on a subset of sites (sites surveyed as part of the statewide deer survey), as the hog deer sites did not have complete vegetation metrics recorded.  

```{r Vegetation, eval = TRUE, echo = FALSE, results = 'hide', message=FALSE,warning=FALSE}
density <- model_fits[[top]]$draws("N_site", format = "matrix")
site_estimates <- list()
site_density <- list()

for(i in 1:n_site) {
  site_estimates[[i]] <- character()
  for(j in 1:length(deer_species_all)) {
    site_estimates[[i]][j] <- paste0("N_site[", j, ",", i, "]")
  }
  site_density[[i]] <- sum(colMeans(density)[site_estimates[[i]]])
}

site_density_ul <- unlist(site_density)

site_density_df <- cams_curated %>%
  mutate(AllDeerDensity = site_density_ul, 
         Bioregion = factor(multispecies_data$site_bioreg), 
         EVC = factor(multispecies_data$site_evc)) %>% 
  filter(ProjectShortName == "StatewideDeer") %>% 
  left_join(multispecies_data[["raw_data"]] %>% select(-EVC, - BIOREGION)) %>%
  mutate(TSLF_bin = as.factor(round(TSLF_bin)))

 site_vars <- dplyr::tbl(con, dbplyr::in_schema("deervic", "curated_site_data")) %>%
    dplyr::filter(SiteID %in% !!c(cams_curated$SiteID, "47191")) %>%
    dplyr::collect() %>%
    dplyr::mutate(HerbaceousUnderstoryCover = NNWHUCover + ENWHUCover,
                  Exotics = EWUCover + ENWHUCover,
                  ExoticPresence = as.integer(as.logical(Exotics)),
                  SeedlingsOrSaplings = as.integer(as.logical(Seedlings+Saplings)),
                  SeedlingsPresence = as.integer(as.logical(Seedlings)),
                  SaplingsPresence = as.integer(as.logical(Saplings)),
                  SiteID = dplyr::case_when(SiteID == "47191" & CameraID == "HO04101053" ~ "47191A",
                                            SiteID == "47191" & CameraID != "HO04101053" ~ "47191B",
                                            TRUE ~ SiteID)) %>% # native + exotic herbaceous cover
    dplyr::arrange(SiteID) %>%
    as.data.frame()
 
 site_density_df_joined <- site_density_df %>% 
   left_join(site_vars) %>%
   mutate(BGroundCover = ifelse(BGroundCover == 0, 0.125, BGroundCover)/100, 
             NWUCover = ifelse(NWUCover == 0, 0.125, NWUCover)/100, 
             NNWHUCover = ifelse(NNWHUCover == 0, 0.125, NNWHUCover)/100)
```

## Model Execution 

We use the `brms` package to run our model in a Bayesian framework [@brms1; @brms2; @brms3]. Our model is run in parallel on four cores over four chains for 1,000 sampling iterations per chain (1,000 warm up iterations). 

```{r VegetationModel, eval = FALSE, echo = FALSE, results = 'hide', message=FALSE,warning=FALSE}
bform1 <- bf(mvbind(BGroundCover, 
                    NWUCover, 
                    NNWHUCover, 
                    Seedlings,
                    Saplings,
                    ExoticPresence) ~ AllDeerDensity
                                    + scale(BIO01)
                                    + scale(BIO04)
                                    + scale(BIO06)
                                    + scale(BIO12)
                                    + scale(BIO15)
                                    + scale(Nitrogen)
                                    + TSLF_bin
                                    + scale(TWIND)
                                    + scale(sqrt(ForestEdge))
                                    + scale(sqrt(CanopyCov))
                                    + scale(sqrt(TopHeight))
                                    + (1|EVC)) 


vegfit <- brm(bform1, 
            data = site_density_df_joined, 
            family = list(Beta(link = "logit"), 
                          Beta(link = "logit"),
                          Beta(link = "logit"),
                          negbinomial(),
                          negbinomial(),
                          bernoulli(link = "logit")),
            inits = "0",
            chains = 4, 
            cores = 4, 
            iter = 2000, 
            warmup = 1000,
            backend = "cmdstanr")

saveRDS(vegfit, "outputs/models/vegfit.rds")
```

## Model Results 

### Model Summary  

Below we show a complete summary of the model, including all coefficients estimated for all the parameters and response variables. Standard deviations for the EVC random effect and the estimates of the $\phi$ parameter in the beta-distribution models, and the shape parameter in the negative binomial models are also shown. Note that all Rhats > 1.05 and all ESS > 200, suggesting good chain mixing and convergence.   

```{r VegOutcomes, warning = FALSE, out.width='1200px', size='small'}
vegfit <- readRDS("outputs/models/vegfit.rds")
veg_coefs <- fixef(vegfit, probs = c(0.05, 0.95), pars = c("BGroundCover_AllDeerDensity", 
                                                             "NWUCover_AllDeerDensity", 
                                                             "NNWHUCover_AllDeerDensity", 
                                                             "Seedlings_AllDeerDensity", 
                                                             "Saplings_AllDeerDensity", 
                                                             "ExoticPresence_AllDeerDensity")) %>%
  as.data.frame() %>%
  mutate(Effect = paste0(c("Bare Ground Cover",
                           "Native Woody Understorey Cover",
                           "Native Non-woody Understorey Cover", 
                           "Presence of seedlings",
                           "Presence of saplings",
                           "Presence of exotic flora"), " ~ Deer Density"))

print_conditional <- function(x, i, d = 3, OR = FALSE) {
  row <- x[i,]
  name <- "\\beta"
  if(OR) {
    row <- row %>%
      mutate(across(where(is.numeric), exp))
    name <- "OR"
  }
  
paste0("$",name,"$ = ", round(row[["Estimate"]], d), " [90% CI: ", round(row[["Q5"]], d), ", ", round(row[["Q95"]], d), "]")
}


summary(vegfit) 
```

### Deer Density Conditional Effects  

Given our main interest in the model is deer density and how it impacts the suite of response variables, we generate marginal/conditional effects plots for the relationship between deer and the vegetation metric. Based on these plots we can see a "significant" (confidence intervals not-overlapping zero) effect of deer density on: bare ground (-ve), native woody understorey (-ve), native non-woody/herbaceous understorey (+ve), and presence of exotic species (+ve):  

```{r VegPlots, fig.width = 10, fig.height=8, fig.cap="Impact of deer density on a range of vegetation measure, including (A) bare ground cover, (B) native woody understorey, (C) native herbaceous understorey cover, (D) seedlings, (E) saplings, and (F) th presence of exotic species. The line shows the mean estimate, with the shading representing 50% and 90% confidence intervals."}
plot_list <- conditional_effects(vegfit, effects = "AllDeerDensity", prob = 0.9)
plot_list_50 <- conditional_effects(vegfit, effects = "AllDeerDensity", prob = 0.5)

plot_deer_relationship <- function(plot_data, plot_data_50, yaxis) {
  ggplot(plot_data) +
    geom_ribbon(aes(x = AllDeerDensity, ymin = `lower__`, ymax = `upper__`), 
                fill = delwp_cols[["Navy"]], alpha = 0.3) +
    geom_ribbon(aes(x = AllDeerDensity, ymin = `lower__`, ymax = `upper__`), 
                fill = delwp_cols[["Navy"]], alpha = 0.3, data = plot_data_50) +
    geom_smooth(aes(x = AllDeerDensity, y = `estimate__`), 
                colour = delwp_cols[["Navy"]], method = "loess", formula = y~x, linewidth = 2) +
    ylab(paste(yaxis)) +
    xlab("Deer Density (per km^2^)") +
    delwp_theme() +
    theme(axis.title.x = ggtext::element_markdown())
    
}

vegplot <- cowplot::plot_grid(plot_deer_relationship(plot_list[[1]], plot_list_50[[1]], "Bare Ground Cover"), 
                   plot_deer_relationship(plot_list[[2]], plot_list_50[[2]], "Native Woody Understorey Cover"),
                   plot_deer_relationship(plot_list[[3]], plot_list_50[[3]], "Native Herbaceous Understorey Cover"),
                   plot_deer_relationship(plot_list[[4]], plot_list_50[[4]], "Seedling Counts") + scale_y_sqrt(),
                   plot_deer_relationship(plot_list[[5]], plot_list_50[[5]], "Sapling Counts"),
                   plot_deer_relationship(plot_list[[6]], plot_list_50[[6]], "Presence of Exotic Flora"), 
                   ncol = 3, labels = "AUTO")

ggsave(plot = vegplot, filename = "outputs/plots/vegetation_effects_plot.png", width = 3400, height = 2200, units = "px")

vegplot

```

We found deer density to have several plausible relationships with several structural vegetation componentsw, including negative relationships with bare ground cover (`r print_conditional(veg_coefs, 1)`), native woody understorey cover (`r print_conditional(veg_coefs, 2)`), and a positive relationship with native non-woody/herbaceous understorey cover (`r print_conditional(veg_coefs, 3)`). We also found strong evidence suggesting the presence of weeds is more likely at sites with higher densities of deer (`r print_conditional(veg_coefs, i = 6, OR = F)`, `r print_conditional(veg_coefs, i = 6, OR = T)`). We did not find tangible relationships between deer abundance and seedling or sapling counts.   

# Analysis Summary

Our studies detected deer at `r sum(rowSums(multispecies_data$n_obs)>0)`/`r multispecies_data$n_site` cameras across Victoria and some form of deer sign (camera or transect) at `r sum(colSums(multispecies_data$any_seen)>0)`/`r multispecies_data$n_site` sites. Our average estimates of deer density at the `r multispecies_data$n_site` sites ranged from 0 to `r round(max(bind_rows(site_deer_predictions)$mean),1)` deer per km^2^. Across approximately 74,570 km2 of public land in Victoria we estimate total deer abundance of the four species investigated in this study (Sambar, Fallow, Red and Hog) at `r formatC(Nhat_all$trimmed_mean, digits = 0, big.mark = ",", format = "f")` (90 % CI: `r formatC(Nhat_all$q5, digits = 0, big.mark = ",", format = "f")` - `r formatC(Nhat_all$q95, digits = 0, big.mark = ",", format = "f")`. We also find plausible links between deer abundance and increased presence of exotic weed species. 

# Comparisons to other studies  

```{r}
asot_areas <- st_read("data/asot_operational_areas")
asot_abundance <- exactextractr::exact_extract(combined_raster[[1:2]], y = asot_areas, "sum") %>%
  `names<-`(c("Sambar_N", "Fallow_N"))

asot_density <- asot_abundance %>% 
  mutate(Name = asot_areas$area_name, 
         area = st_area(asot_areas) %>% units::set_units("km2"), 
         Sambar_D = Sambar_N/area, 
         Fallow_D = Fallow_N/area)
```

