---
title: "Abundance of Deer in Victoria"
description: |
  Determining abundance of deer species in Victoria using camera trap data
author:
  - name: Justin G Cally
    url: https://justincally.github.io/blog/
    affiliation: Arthur Rylah Institute
    affiliation_url: https://www.ari.vic.gov.au/
date: 2023-07-06
output:
  distill::distill_article:
    self_contained: true
    toc: true # table of content true
    toc_float: true # make 
    depth: 3  # upto three depths of headings (specified by #, ## and ###)
    number_sections: false  ## if you want number sections at each table header
    code_folding: true # awesome buttons to show/hide the code
    theme: yeti
slug: statewidedeer
bibliography: bibliography.bib
---

# Setup

Load in relevant packages for analysis, additionally, connect to the database. Camera trap and site data is stored on the database.

```{r setup, include=TRUE, warnings = FALSE, message=FALSE}
library(cmdstanr)
library(dplyr)
library(sf)
library(bayesplot)
library(loo)
library(gt)
library(terra)
library(caret)
library(tidyterra)
library(tidyr)
library(VicmapR)
library(kableExtra)
check_cmdstan_toolchain(fix = TRUE, quiet = TRUE)
register_knitr_engine(override = FALSE)
options(mc.cores=8)

#### Database connection ####
con <- weda::weda_connect(password = keyring::key_get(service = "ari-dev-weda-psql-01",
                                                username = "psql_user"), username = "psql_user")
```

# Custom Functions

Additional functions used in the data preparation, modelling and analysis are available in the `/functions` directory.

```{r sourcefunctions, results = 'hide', echo =FALSE, message=FALSE}
# Source internal functions
sapply(list.files("functions", full.names = T), source, verbose = F)
```

# Prepare Data

Wrangle and format data for the STAN models for the various species.

## Scope of models

Outline which species should be modeled, and which projects to source data from.

```{r data_params}
# Species to run model for.
deer_species_all <- c("Cervus unicolor", "Dama dama", "Cervus elaphus", "Axis porcinus")
# Projects to select.
project_short_name <- c("hog_deer_2023", "StatewideDeer")
# Buffer for data extraction.
spatial_buffer <- 1000
# Covariate Rasters
raster_files <- "/Volumes/DeerVic\ Photos/Processed_Rasters"
# raster_files <- "data/prediction_raster"
prediction_raster <- "data/prediction_raster/statewide_raster.tif"
# For the integrated model we place limits on the maximum density of deer to integrate over. In cases where there are no detections on the camera this is limited to 15 per km2. In cases where deer were detetected on the camera this is expanded to 50. We believe this is sufficiently high. Very high values of these will be less efficient. 
n_max_no_det <- 15
n_max_det <- 50
```

## Camera locations

Download the camera locations from the database, this table outlines the locations and the deployment history of the cameras.

```{r CamLocs}
cams_curated <- tbl(con, dbplyr::in_schema("camtrap", "curated_camtrap_operation")) %>%
  dplyr::filter(ProjectShortName %in% !!project_short_name) %>% # Only retrieve cam records for hog deer 2023
  dplyr::collect() %>%
  dplyr::arrange(SiteID) %>%
  sf::st_as_sf(., coords = c("Longitude", "Latitude"), crs = 4283) 

n_site <- nrow(cams_curated)
```

## Formulas for detection and abundance

Here we outline formulas to be used in the models. The formulas account for the various fixed-effect parameters.

```{r formulas}
#### Model formulas ####

#### Transect Formula: Survey Only ####
transect_formula <- ~Survey

#### Abundance Formula Options #### 
# Simple Formula
ab_formula_2 <- ~ scale(sqrt(BareSoil)) + scale(sqrt(Nitrogen)) + scale(sqrt(PastureDistance)) + scale(TreeDensity) + scale(sqrt(ForestEdge))

# Simple with Coastal Distance: Hog Deer
ab_formula_3 <- ~ scale(sqrt(BareSoil)) + scale(sqrt(Nitrogen)) + scale(sqrt(PastureDistance)) + scale(TreeDensity) + scale(sqrt(ForestEdge)) + scale(dist_coast) 

#### Detection Formula: Distance-sampling ####
det_formula <- ~ scale(HerbaceousUnderstoryCover) # average detection across all sites #scale(HerbaceousUnderstoryCover)
det_formula2 <- ~1
```

## Create model data

Using the `prepare_model_data()` function we generate the data for the `STAN` model. This function will:\
1. Download data from the database 2. Format that data to match the distance-sampling bins\
3. Organise the counts into sites and group sizes\
4. Generate model matrix of the various submodels (distance-sampling, abundance and transect) 5. Generate data for the prediction process 6. Generate data for the random effect (bioregion)\
7. Generate data for regional predictions (indexing based on DEECA regions)

```{r ModelData}
model_data_file <- "data/model_data.rds"
if(!file.exists(model_data_file)) {
evaluate_transects <- c(TRUE, TRUE, TRUE, TRUE)
model_data <- list()
for(i in 1:length(deer_species_all)) {
  
  if(deer_species_all[i] == "Cervus elaphus") {
    det_to_use <- det_formula2
  } else {
    det_to_use <- det_formula
  }
  
    if(deer_species_all[i] == "Axis porcinus") {
    ab_to_use <- ab_formula_3
  } else {
    ab_to_use <- ab_formula_2
  }
  
model_data[[i]] <- prepare_model_data(species = deer_species_all[i],
                                 projects = project_short_name,
                     buffer = spatial_buffer,
                     detection_formula = det_to_use,
                     abundance_formula = ab_to_use,
                     transect_formula = transect_formula,
                     con = con,
                     raster_dir = raster_files,
                     prediction_raster = prediction_raster,
                     n_max_no_det = n_max_no_det,
                     n_max_det = n_max_det,
                     evaltransects = evaluate_transects[i],
                     snapshot_interval = 2, 
                     hs_df = 1,
                     hs_df_global = 1,
                     hs_scale_global = 2/sqrt(nrow(cams_curated)), # ratio of expected non-zero to zero divided by total observation as per brms convention
                     hs_scale_slab = 1,
                     hs_df_slab = 4)

# not used in model but for plots later
model_data[[i]]$raw_data[is.na(model_data[[i]]$raw_data)] <- 0
model_data[[i]]$transects[is.na(model_data[[i]]$transects)] <- 0

}
names(model_data) <- deer_species_all
saveRDS(model_data, model_data_file)
} else {
  model_data <- readRDS(model_data_file)
}
```

# Model Execution

## Model settings

Below we list the MCMC setting for our model. We run models on eight parallel chains for 1,000 iterations each (300 warmup and 300 sampling). These setting provide us with 4,000 posterior draws (8 x 500).

```{r ModelSettings}
# STAN settings
ni <- 250 # sampling iterations
nw <- 250 # warmup iterations 
nc <- 6 # number of chains
```

## Read in Models

These are the models used in the analysis. The first is an integrated model that requires transect and camera data. The second is a count-only model that just requires the camera data.

```{cmdstan, file = "stan/count_det_nondet_poisson_hs.stan", output.var = "model_poisson", eval = FALSE}

```

```{cmdstan, file = "stan/count_only_poisson_hs.stan", output.var = "model_poisson_co", eval = FALSE}

```

```{r models, echo = FALSE, warning=FALSE}
model_poisson <- cmdstan_model(here::here("stan", "count_det_nondet_poisson.stan"))
model_poisson_co <- cmdstan_model(here::here("stan", "count_only_poisson.stan"))
```

## Fit models

We can fit models using `cmdstanr`. Here we fit models using a poisson distribution. One model for each of the four deer species. To aid convergence `adapt_delta` is increased from the default value.

```{r FitModels, eval = FALSE}
integrated_model <- c(TRUE, TRUE, TRUE, FALSE)
distributions <- c("poisson")
model_fits <- list()

for(j in 1:length(distributions)) {

  for(i in 1:length(deer_species_all)) {

  if(integrated_model[i]) {
    model_to_fit <- get(paste0("model_", distributions[j]))
  } else {
    model_to_fit <- get(paste0("model_", distributions[j], "_co"))
  }

  model_fits[[i]] <- model_to_fit$sample(data = model_data[[i]],
                                         chains = nc,
                                 parallel_chains = nc, 
                                 init = 0.1, 
                                 max_treedepth = 10, 
                                 refresh = 20, 
                                 step_size = 0.01, 
                                 adapt_delta = 0.99,
                                 show_messages = TRUE,
                                 save_warmup = FALSE,
                                 iter_sampling = ni, 
                                 iter_warmup = nw)

  model_fits[[i]]$save_object(paste0("outputs/models/fit_", 
                                     distributions[j], 
                                     "_", 
                                     deer_species_all[i],".rds"))

  }
  
}
```

```{r ReadInModels}
model_fits <- list()

model_dir <- "outputs/models"

for(i in 1:length(deer_species_all)) {
  model_fits[[i]] <- readRDS(paste0(model_dir, "/fit_poisson_", deer_species_all[i], ".rds"))
}

names(model_fits) <-  paste0("fit_poisson_", deer_species_all)
```

# Model Evaluation

Our strategy for model evaluation is to determine if the models of the sparse regression approach (horseshoe-prior regularised model) preform sufficiently well against a null model (no abundance fixed-effect covariates).

## LOO (Leave-One-Out Cross-Validation).

We use leave-one-out cross-validation (LOO-CV); a Bayesian model evaluation process [@Vehtari_2017; @loo_2020] to compare the model against a null model. As long as the model with 'all' parameters performs better than the null models it is suitable to use it exclusively for all analyses and predictions. Importantly, the cross-validation also gives us the ability to compare the predictive performance against a null model. In doing so we see that the model with abundance covariates performs better than a null model. Noting that the null model will still include a random bioregion effect.

```{r, eval=FALSE}
loo_compares <- list()
loo_compare_tables <- list()
for(i in 2:length(deer_species_all)) {
  which_models <- model_fits[stringr::str_detect(models_to_read, pattern = deer_species_all[i])]
  
  loo_compares[[i]] <- list()
  
  for(j in 1:length(which_models)) {
     loo_compares[[i]][[j]] <- which_models[[j]]$loo(cores = 6)
  }
  
  names(loo_compares[[i]]) <- names(which_models)
  loo_compare_tables[[i]] <- loo::loo_compare(loo_compares[[i]]) %>% as.data.frame()
  loo_compare_tables[[i]]$Species <- deer_species_all[i]
}

names(loo_compare_tables) <- deer_species_all[1:2]

loo_table_all <- bind_rows(loo_compare_tables) %>%
        tibble::rownames_to_column(var = "model_full") %>%
  mutate(model = stringr::str_extract(model_full, "poisson|negbin")) %>%
        dplyr::select(Species, model, everything(), -model_full) %>%
        arrange(Species) %>% 
        as.data.frame()

# Plot loo table
  gt(loo_table_all, 
     groupname_col = "Species") %>% 
    fmt_number(decimals = 2) %>%
    tab_style(locations = cells_row_groups(), style = cell_text(weight = "bold"))
    
```

## Posterior predictive checks

Posterior predictive checks allow us to compare the observed data to the model-generated data. For each species we undertake posterior predictive checks for summary statistics relating to the number of deer seen on the cameras at each site. Ideally a well-fit model is able to make predictions that match the observed data. The summary statistics we use for the posterior predictive checks are:

1.  97.5% Quantile of deer seen at a site on a camera
2.  Mean number of deer seen at a site on a camera
3.  Standard deviation of the counts of deer on the cameras\
4.  Average (mean) counts at sites in a scatter plot

### Sambar Deer Model.

```{r ppcSambar, fig.width = 6, fig.height = 6, message = F, fig.cap = "Posterior predictive checks for Sambar Deer"}
q95 <- function(x) quantile(x, 0.95, na.rm = T)
# q25 <- function(x) quantile(x, 0.25, na.rm = T)
q75 <- function(x) quantile(x, 0.75, na.rm = T)
# sd_90 <- function (x, na.rm = FALSE) {
#   quants <- quantile(x, c(0.0, 0.95), na.rm = T)
#   x <- x[x < quants[2] & x > quants[1]]
#   sqrt(var(if (is.vector(x) || is.factor(x)) x else as.double(x),
#     na.rm = na.rm))
# }

funs <- c(q95, mean, sd, ppc_scatter_avg)
titles <- c("95% Percentile", "Mean", "SD", "Average Site Counts")

ppc_sambar <- list()

# funs <- c(prop_zero, mean, q90, sd)

for(i in 1:length(funs)) {
ppc_sambar[[i]] <- posterior_checks(model = model_fits[[1]], 
                 model_data = model_data$`Cervus unicolor`, 
                 stat = funs[[i]], 
                 integrated = T, 
                 title = titles[i])
}

cowplot::plot_grid(plotlist = ppc_sambar, labels = "AUTO")
```

### Fallow Deer Model

```{r ppcFallow, fig.width = 6, fig.height = 6, message = F, fig.cap = "Posterior predictive checks for Fallow Deer"}
ppc_fallow <- list()

for(i in 1:length(funs)) {
ppc_fallow[[i]] <- posterior_checks(model = model_fits[[2]], 
                 model_data = model_data$`Dama dama`, 
                 stat = funs[[i]], 
                 integrated = F, only_det = F,
                 title = titles[i])
}

cowplot::plot_grid(plotlist = ppc_fallow)
```

### Red Deer Model

```{r ppcRed, fig.width = 6, fig.height = 6, message = F, fig.cap = "Posterior predictive checks for Red Deer"}
funs <- c(max, mean, sd, ppc_scatter_avg)
titles <- c("Maximum", "Mean", "SD", "Average Site Counts")

ppc_red <- list()

for(i in 1:length(funs)) {
ppc_red[[i]] <- posterior_checks(model = model_fits[[3]], 
                 model_data = model_data$`Cervus elaphus`, 
                 stat = funs[[i]], 
                 integrated = T, only_det = F,
                 title = titles[i])
}

cowplot::plot_grid(plotlist = ppc_red)
```

### Hog Deer Model

```{r ppcHog, fig.width = 6, fig.height = 6, message = F, fig.cap = "Posterior predictive checks for Hog Deer"}
ppc_hog <- list()

for(i in 1:length(funs)) {
ppc_hog[[i]] <- posterior_checks(model = model_fits[[4]], 
                 model_data = model_data$`Axis porcinus`, 
                 stat = funs[[i]], 
                 integrated = F, only_det = F,
                 title = titles[i])
}

cowplot::plot_grid(plotlist = ppc_hog)
```

# Model Predictions

Within the STAN model we generate predictions for sampled and unsampled locations. This provides us with site-level abundance estimates as well as estimates across all (unsampled) public forest.

## Site-based Predictions

### Site-based Prediction Map

Visualisation of point-estimates for the various deer species surveyed for in this study.

```{r SiteMap, fig.height = 24, fig.width = 8, fig.cap = "Site-level density estimates for all sites sampled as part of statewide and hog deer surveys"}
vic_regions <- vicmap_query("open-data-platform:delwp_region") %>%
  collect() %>%
  st_transform(3111) %>%
  st_simplify(dTolerance = 500)


site_preds <- function(model, cams_curated) {
  rn_dens <- model$summary("N_site")
  density_at_sites_rn <- cbind(cams_curated, rn_dens)
  
  return(density_at_sites_rn)
}

site_density_plot <- function(densities, regions, species) {
  densities$density <- cut(densities$mean,
                                   breaks = c(0, 0.1, 1, 3, 5, 10, max(densities$mean)),
                                   labels = c("<0.1", "0.1 - 1", "1-3", "3 - 5", "5 - 10", "10+"), include.lowest = T, right = T)
  
  if(species == "Hog") {
    regions <- regions %>% filter(delwp_region == "GIPPSLAND")
    densities <- densities %>% st_filter(regions %>% st_transform(4283))
  }
  
plot <- ggplot2::ggplot(data = densities) +
  ggplot2::geom_sf(data = regions, alpha = 0.75, fill = "grey80") +
  ggplot2::geom_sf(aes(fill = density, alpha = mean), shape = 21, size = 4) +
  scale_fill_viridis_d(name = "", guide = guide_legend(override.aes = list(size = 6))) +
  scale_alpha_continuous(range = c(0.5,1), guide = "none") +
  labs(title = paste0('Density of ',species ,' Deer'), fill = bquote('Deer per'~km^2)) +
  theme_bw() +
  theme(legend.text = element_text(size = 18), legend.key.size = unit(1, "cm"),
        title = element_text(size = 22))
  
return(plot)
  
}

sambar_preds <- site_preds(model_fits[[1]], cams_curated = cams_curated)
fallow_preds <- site_preds(model_fits[[2]], cams_curated = cams_curated)
red_preds <- site_preds(model_fits[[3]], cams_curated = cams_curated)
hog_preds <- site_preds(model_fits[[4]], cams_curated = cams_curated)

cowplot::plot_grid(site_density_plot(sambar_preds, vic_regions, species = "Sambar"),
site_density_plot(fallow_preds, vic_regions, species = "Fallow"),
site_density_plot(red_preds, vic_regions, species = "Red"),
site_density_plot(hog_preds, vic_regions, species = "Hog"), ncol = 1)
```

### Site-density Summaries

As a sanity-check we compare the average modelled densities at sites with (i) no evidence of deer, (ii) evidence of deer present on transects, and (iii) evidence of deer present on cameras. We expect that average densities are generally higher at sites that detected some form of deer than sites that did not detect any sign of deer. Additionally, we would also expect average densities to be generally higher at sites that had detections on cameras than those with only detections from transects. The table below shows these expectations to be correct for Sambar and partially for Fallow. Red Deer had too few detections for this check to be comprehensive but alongside Hog Deer, Red Deer density was higher at sites with detections on the camera than those where they weren't seen.

```{r siteSummary, warning = FALSE, message = FALSE}
density_summary_table <- function(preds, model_data, species) {
  
  cam_seen <- as.integer(as.logical(rowSums(model_data$n_obs)))
  
  preds_sum <- preds %>% 
    st_drop_geometry() %>%
    mutate(`Species` = species,
           `CameraDetection` = cam_seen, 
           `AnyDetection` = model_data$any_seen, 
           `Detection` = case_when(CameraDetection == 0 & AnyDetection == 0 ~ "Not seen", 
                                   CameraDetection == 0 & AnyDetection == 1 ~ "Only detected on transects", 
                                   CameraDetection == 1 & AnyDetection == 1 ~ "Seen on cameras")) %>%
    group_by(`Species`, `Detection`) %>%
    summarise(`Number of Sites` = n(),
              `Average Density` = mean(mean)) %>%
    ungroup()
  
  return(preds_sum)
}

density_summary <- bind_rows(
  density_summary_table(sambar_preds, model_data[[1]], species = "Sambar"),
  density_summary_table(fallow_preds, model_data[[2]], species = "Fallow"),
  density_summary_table(red_preds, model_data[[3]], species = "Red"),
  density_summary_table(hog_preds, model_data[[4]], species = "Hog"))

density_summary %>%
  kbl(format = "html", digits = 2) %>%
  kable_styling("striped") %>%
  collapse_rows(1)
```

## Regional and Statewide Abundance

Within our model we calculate abundance/density for deer in each of the `r model_data[[1]]$npc` km^2^ of public land. Based on these spatial predictions we can estimate abundance at a regional level (6 DEECA regions) and across the whole state. 

### Statewide Maps 

Using the model predictions ("pred") for all suitable public land we generate a raster (1km^2^ resolution). We save the average spatial estimates under `outputs/rasters` (tif files) and also provide binned plots (png files) in `outputs/plots`.

```{r PredictionRasters}
pred_raster_full <- terra::rast(prediction_raster)

pred_raster <- terra::app(pred_raster_full[[stringr::str_subset(
  stringr::str_remove_all(labels(terms(ab_formula_3)),
                          "scale[(]|[)]|sqrt[(]"), 
  pattern = "[*]", negate = T)]], mean)

mean_raster <- list()
mean_raster_discrete <- list()

for(i in 1:length(model_fits)) {

gp_preds_draws_all <- model_fits[[i]]$draws("pred", format = "matrix")

terra::values(pred_raster)[!is.na(terra::values(pred_raster))] <- apply(gp_preds_draws_all, 
                                                                        2, 
                                                                        mean, 
                                                                        na.rm = T, 
                                                                        trim = 0)

mean_raster[[i]] <- pred_raster
mean_raster_discrete[[i]] <- mean_raster[[i]]
max_pred <- max(values(mean_raster[[i]]), na.rm = T)

values(mean_raster_discrete[[i]]) <- cut(values(mean_raster_discrete[[i]]) , 
                                         breaks = c(0, 0.1,1,3,5,10, max_pred), 
                                         include.lowest = T, right = T,
                                         labels = c("0 - 0.1", 
                                                    "0.1 - 1", 
                                                    "1 - 3", 
                                                    "3 - 5",
                                                    "5 - 10", 
                                                    "10 +"))
}

# combine mean rasters together
combined_raster <- rast(mean_raster)
names(combined_raster) <- c("Average Sambar Deer Density (per km2)", 
                            "Average Fallow Deer Density (per km2)", 
                            "Average Red Deer Density (per km2)", 
                            "Average Hog Deer Density (per km2)")

writeRaster(combined_raster, "outputs/rasters/combined_deer_average_density.tif", overwrite = T)
```

```{r PlotSave, fig.height=24, fig.width=8, fig.cap="Abundance of Sambar, Fallow, Red and Hog Deer across Victoria, dark-grey area reflects area not included in predictions (i.e. not public land)"}
# reg <- VicmapR::vicmap_query("open-data-platform:delwp_region") %>%
#     VicmapR::collect() %>%
#   sf::st_transform(3111) %>%
#   sf::st_simplify(dTolerance = 250) 
state <- VicmapR::vicmap_query("open-data-platform:vmlite_victoria_polygon_su5") %>%
  filter(state != "NSW" & state != "SA" & feature_type_code != "sea") %>%
  VicmapR::collect() %>%
  sf::st_transform(3111)

gippsland <- vic_regions %>% filter(delwp_region == "GIPPSLAND")


plot_abundance <- function(raster, state, species, crop = NULL) {
  
  if(!is.null(crop)) {
    raster <- terra::crop(raster, vect(crop), mask = T)
    state <- crop
  }
  
  plot <- ggplot2::ggplot() +
    ggplot2::geom_sf(data = state, alpha = 0.5, linewidth = 0.5, fill = "grey80") + 
    tidyterra::geom_spatraster(data = raster, na.rm = T) + 
    tidyterra::scale_fill_terrain_d(na.translate = FALSE) + 
    ggplot2::labs(fill = bquote('Deer per'~km^2), title = paste0("Average Density of ", species, " on Victorian Public Land")) + 
    ggspatial::annotation_scale() 
  
  return(plot)
  
} 

sambar_abundance_plot <- plot_abundance(mean_raster_discrete[[1]], 
                                        state = state, 
                                        species = "Sambar Deer")
fallow_abundance_plot <- plot_abundance(mean_raster_discrete[[2]], 
                                        state = state, 
                                        species = "Fallow Deer")
red_abundance_plot <- plot_abundance(mean_raster_discrete[[3]], 
                                     state = state, 
                                     species = "Red Deer")
hog_abundance_plot <- plot_abundance(mean_raster_discrete[[4]], 
                                     state = state, 
                                     species = "Hog Deer", 
                                     crop = gippsland)

ggsave(plot = sambar_abundance_plot, filename = "outputs/plots/sambar_abundance_plot.png", 
       width = 2400, height = 1600, units = "px")
ggsave(plot = fallow_abundance_plot, filename = "outputs/plots/fallow_abundance_plot.png", 
       width = 2400, height = 1600, units = "px")
ggsave(plot = red_abundance_plot, filename = "outputs/plots/red_abundance_plot.png", 
       width = 2400, height = 1600, units = "px")
ggsave(plot = hog_abundance_plot, filename = "outputs/plots/hog_abundance_plot.png", 
       width = 2400, height = 1600, units = "px")

cowplot::plot_grid(sambar_abundance_plot, fallow_abundance_plot, red_abundance_plot, hog_abundance_plot, ncol = 1)
```

### Regional Abundance Estimates  

For each DEECA region we provide species-level estimates of abundance with 90 % confidence interval. We also calculate the modle-based average density within each region based on the abundance and the total area of public land within each region.  

```{r}
reg <- VicmapR::vicmap_query("open-data-platform:delwp_region") %>%
    VicmapR::collect() %>%
    dplyr::group_by(delwp_region) %>%
    dplyr::summarise(geometry = sf::st_combine(geometry)) %>%
    dplyr::ungroup() %>%
    dplyr::mutate(delwp_region_fact = as.integer(factor(delwp_region))) 

abundance_table <- function(model, regions, pred_area, caption) {
  regional_abundance <- model$summary("Nhat_reg") %>%
    dplyr::bind_rows(model$summary("Nhat")) %>% 
    dplyr::mutate(variable = c(regions$delwp_region, "TOTAL"), 
                  `Area km2` = c(pred_area, sum(pred_area)), 
                  `Average Density (per km2)` = round(mean/`Area km2`, 2)) %>% 
    dplyr::select(Region = variable, 
                  Mean = mean, 
                  Median = median, 
                  SD = sd, 
                  `5 %` = q5, 
                  `90 %` = q95, 
                  `Area km2`,
                  `Average Density (per km2)`)
  
  kableExtra::kbl(regional_abundance, digits = 1, format = "html", caption = caption) %>%
    kableExtra::kable_styling("striped") %>%
    kableExtra::column_spec(1, bold = TRUE) %>%
    kableExtra::row_spec(6, hline_after = T) %>%
    kableExtra::row_spec(7, background = "#c2a5cf", color = "black", bold = T, hline_after = T)
}

abundance_table(model_fits[[1]], regions = reg, pred_area = table(model_data[[1]]$pred_reg), caption = "Regional estimates of Sambar Deer Density")
abundance_table(model_fits[[2]], regions = reg, pred_area = table(model_data[[2]]$pred_reg), caption = "Regional estimates of Fallow Deer Density")
abundance_table(model_fits[[3]], regions = reg, pred_area = table(model_data[[3]]$pred_reg), caption = "Regional estimates of Red Deer Density")
abundance_table(model_fits[[4]], regions = reg, pred_area = table(model_data[[4]]$pred_reg), caption = "Regional estimates of Hog Deer Density")
```

# Model Covariates  

Our model uses covariates to inform three seperate submodels:  

+ A distance-sampling detection process in front of the camera   
+ An imperfect detection/observation model based on the transect methods and the camera survey  
+ An abundance model based on spatially-derived convariates, as well as a bioregion random effect.   

## Detection Processes  

At a site, there are two processes that may lead us to not record deer on a camera when in reality they occupy the site (whereby the site is the home range area surrounding the camera.) Firstly, deer may be available for detection and enter the sampling area in front of the camera. However, due to a function of their distance from the camera we fail to detect this individual. Secondly, they may occupy a site (known from transect signs) but never enter the camera field of view, in this case we estimate the various detection rates from the various methods. The detection rate of the camera in this method is regarded as the spatial availability of deer for camera trap sampling. 

### Distance-sampling

Below we show the average detection rate for a given group of deer in front of the camera (up to 12.5m). Detection rastes appear to be higher for Sambar than other species.  

```{r AverageDetectionRates}
species_names <- c("Sambar Deer", "Fallow Deer", "Red Deer", "Hog Deer")
av_det_rates <- list()
for(i in 1:length(model_fits)) {
det_rates <- model_fits[[i]]$summary("p") %>%
  mutate(var = stringr::str_extract(variable, "(?<=\\[).+?(?=\\])")) %>%
  separate(var, into = c("site", "Group Size"), sep = ",")

av_det_rates[[i]] <- det_rates %>%
  group_by(`Group Size`) %>%
  summarise(mean = mean(mean)) %>%
  ungroup() %>% 
  transmute(`Group Size`, 
            Species = species_names[i], 
            `Average Site Detection Probability` = mean)

}

av_det_rates %>%
  bind_rows() %>%
  arrange(`Group Size`) %>%
  kbl("html", digits = 3, caption = "Average detection rates for the different species and different group sizes") %>%
  kable_styling("striped") %>%
  collapse_rows(1)
```

For a group size of 1 we can generate detection function plots that show how detection rates fall-off over varying distances.  

*Note the following data suggests we should test hazard functions for Fallow, Red and Hog*. 

```{r DistancePlots, fig.caption="Distance-sampling detection process for Sambar Deer (group size = 1). Herbaceous understorey cover in the area surrounding the camera impacts detection probability.", fig.width = 8, fig.height = 6}
site_vars <- dplyr::tbl(con, dbplyr::in_schema("deervic", "curated_site_data")) %>%
    dplyr::filter(SiteID %in% !!c(cams_curated$SiteID, "47191")) %>%
    dplyr::collect() %>%
    dplyr::mutate(HerbaceousUnderstoryCover = NNWHUCover + ENWHUCover,
           SiteID = dplyr::case_when(SiteID == "47191" & CameraID == "HO04101053" ~ "47191A",
                              SiteID == "47191" & CameraID != "HO04101053" ~ "47191B",
                              TRUE ~ SiteID)) %>% # native + exotic herbaceous cover
    dplyr::arrange(SiteID) %>%
    as.data.frame()

  n_distance_bins <- 5
  delta <- 2.5
  midpts <- c(1.25, 3.75, 6.25, 8.75, 11.25)
  max_distance <- 12.5
  
  detection_plot_HN <- list()
  
for(i in 1:length(species_names)) {

det_curve <- model_fits[[i]]$draws("DetCurve", format = "draws_matrix") %>%
  as.data.frame() %>%
  head(250) %>%
  pivot_longer(cols = everything())

det_curve_wr <- det_curve %>%
  mutate(var = stringr::str_extract(name, "(?<=\\[).+?(?=\\])")) %>%
  separate(var, into = c("s", "Distance"), sep = ",")

det_vars_pred <- site_vars %>%
  mutate(s = as.character(1:nrow(.)),
         herbaceouslvl = cut(HerbaceousUnderstoryCover,
                             breaks = c(0, 25, 50, 75, 105), 
                             labels = c("0 - 25%", 
                                        "25 - 50%", 
                                        "50 - 75%", 
                                        "75 - 100%"),
                             include.lowest = T, right = FALSE))

det_curve_sum <- det_curve_wr %>%
  mutate(Distance = as.numeric(Distance)-1) %>%
  left_join(det_vars_pred) %>%
  group_by(herbaceouslvl, Distance) %>%
  summarise(median = quantile(value, 0.5),
            q5 = quantile(value, 0.05),
            q95 = quantile(value, 0.95))


y_combined <- colSums(model_data[[i]]$y[,,1]) %>% # just for group size 1
  as.data.frame() %>%
  `colnames<-`("Count") %>%
  mutate(Distance = midpts,
         Prop = Count/(max(Count)),
         CountS = Count/(2 * 2.5 * Distance)/max_distance^2,
         PropS = CountS/(max(CountS)))

detection_plot_HN[[i]] <- ggplot(aes(x = Distance), data = det_curve_sum) +
  geom_col(aes(y = PropS), fill = "grey70", colour = "grey20", width = 2.5, data = y_combined, alpha = 0.7) +
  # geom_errorbar(aes(ymin = PropSq5, ymax = PropSq95),  data = y_combined) +
  # geom_line(aes(y = HNS)) +
  geom_ribbon(aes(ymin = q5, ymax = q95, fill = herbaceouslvl), alpha = 0.5) +
  geom_line(aes(y = median, colour = herbaceouslvl)) +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0), limits = c(0,1)) +
  scale_fill_brewer(palette = "Set1") +
  scale_colour_brewer(palette = "Set1") +
  ylab("Detection probability (p)") +
  labs(fill = "Herbaceous\nUnderstorey\nCover", colour = "Herbaceous\nUnderstorey\nCover") +
  theme_classic()

}

cowplot::plot_grid(plotlist = detection_plot_HN, ncol = 2)
```

### Transect-surveys  

For Sambar, Fallow and Red Deer we were able to estimate detection rates of the various methods used to detect deer (camera, footprints, pellets, rubbings and wallows).

```{r detectionplots, fig.width=10, fig.height=4, fig.cap="Detection Probability for the various methods of survey. Camera trap detection probability is based on average deployment length, while transects are based on 3 independent transect searches"}
det_data_species <- list()
for(j in 1:3) {
  
all_draws <- model_fits[[j]]$draws("beta_trans_det", format = "df")

det_marginal_effects <- list()
det_plot <- list()

obs_vars <- unlist(stringr::str_remove_all(string = labels(terms(transect_formula)), pattern =  "log|scale|\\)|\\("))
obs_cols <- unlist(stringr::str_remove_all(string = colnames(model_data[[j]]$trans_pred_matrix), pattern =  "log|scale|\\)|\\("))
obs_logs <- unlist(stringr::str_detect(string = colnames(model_data[[j]]$trans_pred_matrix), pattern =  "log\\("))

obs_labs <- c("Survey Method")

fac <- c(TRUE, TRUE, TRUE, TRUE, TRUE)
fac2 <- c(TRUE)

det_obs <- model_data[[j]]$transects %>% 
  mutate(Survey = factor(Survey))

params_w_levs <- levels(det_obs$Survey)

for(i in 1:(length(obs_cols))) {
det_marginal_effects[[i]] <- marginal_effects_cmd(all_draws, 
                                              param = "beta_trans_det", 
                                              param_number = i, log = obs_logs[i],
                                     model_data = det_obs, 
                                     model_column = obs_vars[c(1,attr(model_data[[j]]$trans_pred_matrix, "assign")[-1])[i]], 
                                     transition = FALSE) %>%
  mutate(group = param, 
         param = params_w_levs[i], 
         factor = fac[i], 
         variable = as.numeric(variable))

if(fac[i]) {
  det_marginal_effects[[i]] <- det_marginal_effects[[i]]
}

}

marginal_prob <- function(x, pwr = 3) {
  xm <- 1-x
  return(1-(xm^pwr))
}

det_marginal_effects_bind <- bind_rows(det_marginal_effects) %>%
  rowwise() %>%
  mutate(value = case_when(param != "Camera" ~ marginal_prob(value), 
                           TRUE ~ value))

det_marginal_effects_split <- split(det_marginal_effects_bind, det_marginal_effects_bind$group)

for(i in 1:length(det_marginal_effects_split)) {
  
  if(fac2[i]) {
    plot_data <- det_marginal_effects_split[[i]] %>% 
      mutate(variable = param, 
             param = group)
  } else {
    plot_data <- det_marginal_effects_split[[i]]
  }

det_plot[[i]] <- plot_data

}
det_data_species[[j]] <- bind_rows(det_plot) %>%
  mutate(species = species_names[j])
}

data_for_plot <- bind_rows(det_data_species)

marginal_effects_plot_cmd_all(data_for_plot, 
                              factor = TRUE,
                              ylab = "Detection probability") +
  xlab("Survey method") +
  scale_y_continuous(limits = c(0,1)) +
  theme(legend.position = "top") +
  scale_fill_brewer(palette = "Set1") +
  scale_x_discrete(expand = c(0, 0))

```

## Abundance Processes

### Bioregion

We used a spatially-derived random-effect of the bioregion of the sampled site. This random-effect allows us the ability to make predictions that include the variance associated with this random effect. This random-effect also minimises predictions in areas without deer detections (e.g. the mallee).

```{r bioregions, fig.height=24, fig.width = 5, fig.cap="Influence of the bioregion random effect on abundance (log-scale). "}
bioregion_contribution <- function(model, data, species) {
  eps_bioregion <- model$draws("eps_bioregion", format = "matrix")
  bioregion_data <- data[["bioreg_sf"]]
  colnames(eps_bioregion) <- bioregion_data$bioregion
  
  plot <- mcmc_areas(eps_bioregion, prob_outer = 0.9) +
    ggtitle(species)
  
  return(plot)
}

bio_plot_data <- list()

for(i in 1:length(species_names)) {
 bio_plot_data[[i]] <- bioregion_contribution(model = model_fits[[i]], 
                         data = model_data[[i]], 
                         species = species_names[i])
} 

cowplot::plot_grid(plotlist = bio_plot_data, ncol = 1)
```

### Fixed-parameter Effects

```{r FixedEffects, fig.height=10, fig.width = 14, warning = FALSE, message = FALSE, fig.cap="Marginal response curves for the various fixed-effect parameters used in the model."}
ab_joined_list <- list()
for(j in 1:length(species_names)) {
beta_draws <- model_fits[[j]]$draws("beta_psi", format = "df")

ab_marginal_effects <- list()
ab_plot <- list()

    if(deer_species_all[j] == "Axis porcinus") {
    ab_to_use <- ab_formula_3
  } else {
    ab_to_use <- ab_formula_2
  }

phi_vars <- unlist(stringr::str_remove_all(string = labels(terms(ab_to_use)), pattern =  "log|scale|sqrt|\\)|\\("))
phi_logs <- unlist(stringr::str_detect(string = labels(terms(ab_to_use)), pattern =  "log\\("))
phi_sqrts <- c(0.5,0.5,0.5,1,0.5,1)

phi_labs <- c("Bare Soil (%)", 
              "Nitrogen (%)", 
              "Distance to Pastural Land (m)", 
              "Tree Density (%)", 
              'Length of forest edge in 1km2 (m)', 
              "Geographical Distance to coastline")

fac <- c(FALSE, FALSE, FALSE, FALSE, FALSE, FALSE)

for(i in 1:length(phi_vars)) {
ab_marginal_effects[[i]] <- marginal_effects_cmd(beta_draws, 
                                              param = "beta_psi", 
                                              param_number = i+1, log = phi_logs[i],
                                     model_data = model_data[[j]][["raw_data"]], 
                                     abundance = TRUE,
                                     pwr = phi_sqrts[i],
                                     model_column = phi_vars[i], 
                                     transition = FALSE) %>%
  mutate(species = species_names[j])

}
ab_joined_list[[j]] <- bind_rows(ab_marginal_effects)
}

all_me_data <- bind_rows(ab_joined_list) %>%
  mutate(param = case_when(param == "BareSoil" ~ "Bare Soil (%)", 
                           param == "Nitrogen" ~ "Nitrogen (%)", 
                           param == "PastureDistance" ~ "Distance to Pastural Land (m)", 
                           param == "TreeDensity" ~ "Tree Density (%)", 
                           param == "ForestEdge" ~ 'Amount of Forest Edge per km2 (m)', 
                           param == "dist_coast" ~ "Geographical Distance to Coast"))
  

marginal_effects_plot_cmd_all(all_me_data, 
                          col = "DarkGreen", 
                          factor = FALSE,
                          ylab = "Contribution to Abundance (log-scale)") +
      ggplot2::facet_grid(species~param, scales = "free") +
  theme_bw() +
  xlab("Covariate Value")
```
